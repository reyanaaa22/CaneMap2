<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>CaneMap - Tasks & Growth Tracker</title>
  <link rel="stylesheet" href="../../css/output.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    :root {
      --cane-50: #f0f7e9;
      --cane-100: #d4e8b3;
      --cane-200: #b8d97d;
      --cane-300: #9bcb47;
      --cane-400: #7fbd11;
      --cane-500: #2c5a0b;
      --cane-600: #3a7a0f;
      --cane-700: #2c5a0b;
      --cane-800: #1e3e08;
      --cane-900: #1a3607;
      --cane-950: #0f1f04;
    }

    .section-card {
      background: white;
      border: 1px solid var(--cane-200);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    /* Allow dropdown to overflow */
    .section-card.field-select-card {
      overflow: visible !important;
    }

    .inner-box {
      background: var(--cane-50);
      border: 1px solid var(--cane-200);
    }

    .badge {
      padding: .15rem .5rem;
      border-radius: .375rem;
      font-size: .75rem;
      font-weight: 600;
    }

    .badge-done {
      background: #e6f7e6;
      color: #0d5a0d;
      border: 1px solid #b3e6b3;
    }

    .badge-progress {
      background: #e6f0ff;
      color: #1d4ed8;
      border: 1px solid #bfdbfe;
    }

    .badge-not {
      background: #fff3e6;
      color: #8c4d00;
      border: 1px solid #ffd9b3;
    }

    .badge-delayed {
      background: #ffe6e6;
      color: #b30000;
      border: 1px solid #ffb3b3;
    }

    .stage-active {
      border-color: var(--cane-600);
      box-shadow: 0 0 0 2px rgba(58, 122, 15, 0.5);
    }

    .drop-zone {
      border: 2px dashed var(--cane-300);
      background: rgba(212, 232, 179, 0.2);
    }

    /* Unified Timeline Styles */
    .timeline-stage {
      position: relative;
    }

    .stage-indicator {
      transition: all 0.3s ease;
      z-index: 2;
    }

    .stage-indicator.active {
      transform: scale(1.2);
      box-shadow: 0 0 0 4px rgba(58, 122, 15, 0.2);
    }

    .stage-indicator.completed {
      background: var(--cane-600);
    }

    .stage-indicator.in-progress {
      background: var(--cane-400);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Modal Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-fadeIn {
      animation: fadeIn 0.2s ease-out;
    }

    .animate-slideUp {
      animation: slideUp 0.3s ease-out;
    }

    /* Record Modal Styles */
    .record-info-card {
      background: white;
      border-radius: 0.75rem;
      padding: 1.25rem;
      border: 1px solid #e5e7eb;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      transition: all 0.2s;
    }

    .record-info-card:hover {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.08);
    }

    .record-info-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.375rem;
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }

    .record-info-value {
      font-size: 0.9375rem;
      font-weight: 600;
      color: #111827;
      line-height: 1.5;
    }

    .record-section-title {
      font-size: 1rem;
      font-weight: 700;
      color: #111827;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding-bottom: 0.75rem;
      border-bottom: 2px solid var(--cane-200);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.375rem 0.75rem;
      border-radius: 0.5rem;
      font-size: 0.8125rem;
      font-weight: 600;
      text-transform: capitalize;
    }

    .status-badge.germination {
      background: #dbeafe;
      color: #1e40af;
    }

    .status-badge.tillering {
      background: #d1fae5;
      color: #065f46;
    }

    .status-badge.grand-growth {
      background: #fef3c7;
      color: #92400e;
    }

    .status-badge.maturing {
      background: #fce7f3;
      color: #9f1239;
    }

    .status-badge.harvest {
      background: #e0e7ff;
      color: #3730a3;
    }

    /* Limit height of activity lists per stage and make scrollable when many records */
    .activities-stage-list {
      max-height: 260px; /* roughly 4 nodes tall */
      overflow-y: auto;
      padding-right: 0.25rem;
    }

    .activity-node {
      background: white;
      border: 1px solid var(--cane-200);
      border-left: 3px solid var(--cane-600);
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-left: 1.5rem;
      transition: all 0.2s ease;
      cursor: pointer;
      position: relative;
    }

    .activity-node:hover {
      background: var(--cane-50);
      border-left-color: var(--cane-700);
      transform: translateX(4px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .activity-node button {
      background: none;
      border: none;
      padding: 0;
      width: 100%;
      text-align: left;
      cursor: pointer;
    }

    .activity-node.empty-state {
      border-left-color: var(--cane-200);
      background: var(--cane-50);
      cursor: default;
      opacity: 0.6;
    }

    .activity-node.empty-state:hover {
      transform: none;
      box-shadow: none;
    }

    @media print {

      #btnDownloadPDF,
      #btnPrint {
        display: none !important;
        visibility: hidden !important;
      }

      /* prevent card/page breaks */
      .section-card,
      .inner-box {
        page-break-inside: avoid;
      }
    }

    /* Tooltip container */
    .btn-tooltip {
      position: relative;
    }

    /* Tooltip bubble appears BELOW */
    .btn-tooltip:hover .tooltip-text {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(4px);
    }

    /* Tooltip bubble BELOW */
    /* Custom Dropdown Styles - Dropdown from input */
    .custom-dropdown {
      position: relative;
      width: 100%;
    }

    .dropdown-trigger {
      appearance: none;
      width: 100%;
      padding: 0.5rem 1rem 0.5rem 1rem;
      padding-right: 2.5rem;
      text-align: left;
      font-size: 0.875rem;
      background: white;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: all 0.2s ease;
      border-radius: 0.375rem;
    }

    .dropdown-trigger:hover {
      background-color: var(--cane-50);
    }

    .dropdown-trigger:focus {
      outline: none;
      background-color: var(--cane-50);
      box-shadow: 0 0 0 2px rgba(58, 122, 15, 0.2);
    }

    .dropdown-trigger-icon {
      position: absolute;
      right: 0.75rem;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: auto;
      transition: transform 0.3s ease;
      color: var(--cane-600);
      font-size: 0.875rem;
      cursor: pointer;
    }

    .dropdown-trigger.open .dropdown-trigger-icon {
      transform: translateY(-50%) rotate(180deg);
    }

    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid var(--cane-200);
      border-top: none;
      border-radius: 0 0 0.5rem 0.5rem;
      max-height: 300px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      margin-top: -1px;
    }

    .dropdown-menu.open {
      display: block;
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .dropdown-menu-content {
      width: 100%;
    }

    .dropdown-menu-header {
      display: none;
    }

    .dropdown-menu-close {
      display: none;
    }

    .dropdown-options {
      padding: 0;
    }

    .dropdown-option {
      padding: 0.75rem 1rem;
      border: none;
      background: white;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--cane-800);
      border-bottom: 1px solid var(--cane-100);
      transition: background-color 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .dropdown-option:last-child {
      border-bottom: none;
    }

    .dropdown-option:hover {
      background-color: var(--cane-100);
    }

    .dropdown-option.selected {
      background-color: var(--cane-200);
      color: var(--cane-700);
      font-weight: 600;
    }

    .dropdown-option.selected::after {
      content: '‚úì';
      color: var(--cane-600);
      font-weight: bold;
      margin-left: 0.5rem;
    }

    /* Desktop: Use native select */
    @media (min-width: 768px) {
      .custom-dropdown {
        display: none;
      }

      .native-select-wrapper {
        display: block;
      }
    }

    /* Mobile: Use custom dropdown */
    @media (max-width: 767px) {
      .native-select-wrapper {
        display: none;
      }

      .custom-dropdown {
        display: block;
      }
    }

    .tooltip-text {
      transition: all 0.2s ease;
      opacity: 0;
      visibility: hidden;
      position: absolute;
      top: 100%;
      /* ‚¨Ö DITO para lumabas SA BABA */
      left: 50%;
      transform: translateX(-50%) translateY(0px);
      background: #000000dd;
      color: white;
      padding: 4px 8px;
      font-size: 10px;
      border-radius: 6px;
      white-space: nowrap;
      z-index: 999;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    /* Enhanced Progress Bar Styles */
    .progress-bar-container {
      background: linear-gradient(135deg, #f5f5f5 0%, #ffffff 100%);
      border: 1px solid var(--cane-200);
      border-radius: 0.75rem;
      padding: 1.25rem;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .progress-bar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
    }

    .progress-bar-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--cane-900);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .progress-bar-title i {
      color: var(--cane-600);
    }

    .progress-bar-percentage {
      font-size: 1.5rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--cane-600) 0%, var(--cane-400) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      min-width: 60px;
      text-align: right;
    }

    .progress-bar-track {
      width: 100%;
      height: 12px;
      background: linear-gradient(90deg, #e5e7eb 0%, #f3f4f6 50%, #e5e7eb 100%);
      border-radius: 9999px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--cane-600) 0%, var(--cane-400) 100%);
      border-radius: 9999px;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      box-shadow: 0 0 10px rgba(58, 122, 15, 0.4);
    }

    .progress-bar-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      border-radius: 9999px;
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(100%);
      }
    }

    .progress-bar-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 0.75rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--cane-700);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .progress-bar-label {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }

    .progress-bar-label-value {
      font-size: 0.875rem;
      font-weight: 700;
      color: var(--cane-900);
    }

    @media (max-width: 480px) {
      header .flex.items-center.gap-2 {
        margin-left: auto;
      }
    }
  </style>
</head>

<body class="bg-gradient-to-br from-[var(--cane-50)] to-[var(--cane-100)] min-h-screen text-[var(--cane-900)]">

  <header class="bg-white/90 backdrop-blur border-b border-[var(--cane-200)]">
    <div class="max-w-7xl mx-auto px-4 md:px-6 py-4">

      <div class="flex items-center justify-between w-full">

        <!-- LEFT: Back + Title -->
        <div class="flex items-center gap-3">
          <a href="dashboard.html" id="backArrowBtn" class="text-[var(--cane-700)] hover:text-[var(--cane-800)] transition-colors" onclick="event.preventDefault(); try { if (window.history.length > 1) { window.history.back(); } else { window.location.href = 'dashboard.html'; } } catch(e) { window.location.href = 'dashboard.html'; } return false;">
            <i class="fa-solid fa-arrow-left text-lg"></i>
          </a>
          <h1
            class="text-xl md:text-2xl font-bold bg-gradient-to-r from-[var(--cane-600)] to-[var(--cane-500)] bg-clip-text text-transparent">
            Growth Tracker
          </h1>
        </div>

        <div class="flex items-center gap-2 print:hidden">

          <div class="btn-tooltip">
            <button id="btnDownloadPDF" class="px-3 py-2 bg-white border border-gray-300 shadow-md hover:shadow-lg 
      transition rounded-lg text-xs font-medium flex items-center gap-1">
              <i class="fa-solid fa-file-pdf text-red-600"></i> PDF
            </button>
            <div class="tooltip-text">Download PDF</div>
          </div>

          <div class="btn-tooltip">
            <button id="btnPrint" class="px-3 py-2 bg-white border border-gray-300 shadow-md hover:shadow-lg 
      transition rounded-lg text-xs font-medium flex items-center gap-1">
              <i class="fa-solid fa-print text-blue-600"></i> Print
            </button>
            <div class="tooltip-text">Print Page</div>
          </div>

        </div>

      </div>
  </header>


  <div id="captureArea">
    <main class="max-w-7xl mx-auto px-4 md:px-6 py-6 md:py-10 space-y-8">
      <!-- GROWTH TRACKER HEADER + STATUS like in image -->
      <section class="space-y-4">
        <div class="flex items-start justify-between">
          <div>
            <h2 class="font-semibold text-lg text-[var(--cane-900)]">Growth Tracker</h2>
            <p class="text-sm text-[var(--cane-800)]">Monitor sugarcane growth and estimate harvest times with 90%
              accuracy</p>
          </div>
          <div class="btn-tooltip ml-4">
            <button id="ratoonBtn" class="px-4 py-2 bg-[var(--cane-600)] text-white rounded-lg font-semibold hover:bg-[var(--cane-700)] transition-colors disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap" disabled title="Available only when field is harvested">
              <i class="fa-solid fa-leaf mr-2"></i>Ratoon Field
            </button>
            <span id="ratoonBtnTooltip" class="tooltip-text">Available only when field is harvested</span>
          </div>
        </div>
        <!-- Field select -->
        <div class="section-card field-select-card rounded-xl p-0 overflow-visible">
          <div
            class="px-3 py-2 text-sm text-[var(--cane-700)] bg-[var(--cane-100)] border-b border-[var(--cane-200)] font-medium">
            Select Field</div>

          <!-- Desktop: Native Select -->
          <div class="native-select-wrapper relative">
            <select id="gtField" class="appearance-none w-full px-4 py-2 pr-10 text-sm bg-white focus:outline-none">
              <!-- Options will be populated dynamically by JavaScript -->
            </select>
            <i class="fa-solid fa-chevron-down absolute right-3 top-2.5 text-[var(--cane-600)] text-base"></i>
          </div>

          <!-- Mobile: Custom Dropdown -->
          <div class="custom-dropdown">
            <button class="dropdown-trigger" id="dropdownTrigger">
              <span id="dropdownTriggerText">Select a field</span>
              <i class="fa-solid fa-chevron-down dropdown-trigger-icon"></i>
            </button>

            <!-- Dropdown Menu -->
            <div class="dropdown-menu" id="dropdownMenu">
              <div class="dropdown-menu-content">
                <div class="dropdown-menu-header">
                  <h3>Select Field</h3>
                  <button class="dropdown-menu-close" id="dropdownClose">
                    <i class="fa-solid fa-xmark"></i>
                  </button>
                </div>
                <div class="dropdown-options" id="dropdownOptions"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="flex items-center justify-between">
          <p class="font-semibold text-base" id="fieldStatusTitle">Growth Status</p>
          <p class="text-sm text-[var(--cane-700)]">Planted: <span class="font-semibold" id="plantedDateDisplay">‚Äî</span></p>
        </div>
        <div class="section-card rounded-xl p-4 space-y-4">
          <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">
            <div>
              <div class="text-[var(--cane-800)] mb-1">Crop Variety:</div>
              <div class="inner-box rounded px-3 py-1.5" id="uiVariety">Phil 99-1793</div>
            </div>
            <div>
              <div class="text-[var(--cane-800)] mb-1">Age:</div>
              <div class="inner-box rounded px-3 py-1.5"><span id="uiDays">0</span> Days</div>
            </div>
            <div>
              <div class="text-[var(--cane-800)] mb-1">Location:</div>
              <div class="inner-box rounded px-3 py-1.5">Block 7, Section A</div>
            </div>
            <div>
              <div class="text-[var(--cane-800)] mb-1">Date Planted:</div>
              <div class="inner-box rounded px-3 py-1.5" id="uiPlanted">‚Äî</div>
            </div>
            <div>
              <div class="text-[var(--cane-800)] mb-1">Current Growth Stage:</div>
              <div class="inner-box rounded px-3 py-1.5" id="uiStage">‚Äî</div>
            </div>
            <div>
              <div class="text-[var(--cane-800)] mb-1">Area Size:</div>
              <div class="inner-box rounded px-3 py-1.5" id="uiAreaSize">‚Äî</div>
            </div>
          </div>

          <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">
            <div>
              <div class="text-[var(--cane-800)] mb-1">Fertilizers Used:</div>
              <div class="inner-box rounded px-3 py-1.5" id="uiFertilizers">‚Äî</div>
            </div>
            <div>
              <div class="text-[var(--cane-800)] mb-1">Seed Rate:</div>
              <div class="inner-box rounded px-3 py-1.5" id="uiSeedRate">‚Äî</div>
            </div>
          </div>

          <div class="inner-box rounded-lg p-4">
            <div class="flex items-center justify-between mb-3">
              <div class="flex items-center gap-2 text-base font-semibold"><i
                  class="fa-solid fa-calendar-check text-[var(--cane-700)] mr-1"></i> Harvest Estimate</div>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-base">
              <div>
                <div class="text-[var(--cane-800)] text-xs">Estimated Harvest Date</div>
                <div class="font-semibold" id="uiHarvest">-</div>
                <div class="text-[10px] text-gray-600">¬± 5 days variance</div>
              </div>
              <div>
                <div class="text-[var(--cane-800)] text-xs">Days Remaining</div>
                <div class="font-semibold"><span id="uiRemain">0</span> Days</div>
                <div class="text-[10px] text-gray-600">Approximately <span id="uiMonths">0</span> months</div>
              </div>
            </div>
            <div class="mt-3 flex items-center gap-2 text-[10px] text-gray-700"><i class="fa-solid fa-circle-info"></i>
              90% estimate accuracy based on continuous task logs and timestamps</div>
          </div>

          <!-- Unified Growth & Activity Timeline with Enhanced Progress Bar -->
          <div class="progress-bar-container">
            <div class="progress-bar-header">
              <div class="progress-bar-title">
                <i class="fa-solid fa-chart-line"></i>
                Growth & Activity Timeline
              </div>
              <div class="progress-bar-percentage" id="progressPercentage">0%</div>
            </div>
            <div class="progress-bar-track">
              <div id="tlBar" class="progress-bar-fill" style="width: 0%"></div>
            </div>
            <div class="progress-bar-labels">
              <div class="progress-bar-label">
                <span>Start</span>
                <span class="progress-bar-label-value" id="progressStart">Germination</span>
              </div>
              <div class="progress-bar-label">
                <span>Current</span>
                <span class="progress-bar-label-value" id="progressCurrent">‚Äî</span>
              </div>
              <div class="progress-bar-label">
                <span>Target</span>
                <span class="progress-bar-label-value" id="progressTarget">Harvest</span>
              </div>
            </div>
          </div>

          <!-- Unified Timeline Container -->
          <div id="unifiedTimelineContainer" class="space-y-0">
            <!-- Growth stages with integrated activity records will be rendered here -->

            
            <!-- Germination Stage -->
            <div class="timeline-stage" data-stage="Germination">
              <div class="flex items-start gap-3 pb-4">
                <div class="flex flex-col items-center">
                  <div class="w-4 h-4 rounded-full bg-[var(--cane-600)] border-2 border-white shadow-md stage-indicator" id="stage-germination"></div>
                  <div class="w-0.5 h-full bg-gradient-to-b from-[var(--cane-600)] to-[var(--cane-400)] mt-2 min-h-[40px]" id="connector-germination"></div>
                </div>
                <div class="flex-1 pt-0.5">
                  <div class="flex items-center justify-between mb-2">
              <div>
                      <p class="font-semibold text-sm">Germination</p>
                      <p class="text-xs text-gray-600" id="tlGerm">Status: -</p>
              </div>
                    <span class="badge badge-done text-xs" id="badge-germination" style="display: none;">Active</span>
            </div>
                  <div id="activities-germination" class="mt-3 space-y-2 activities-stage-list">
                    <!-- Activity records for this stage will be inserted here -->
                  </div>
                </div>
              </div>
            </div>

            <!-- Tillering Stage -->
            <div class="timeline-stage" data-stage="Tillering">
              <div class="flex items-start gap-3 pb-4">
                <div class="flex flex-col items-center">
                  <div class="w-4 h-4 rounded-full bg-[var(--cane-400)] border-2 border-white shadow-md stage-indicator" id="stage-tillering"></div>
                  <div class="w-0.5 h-full bg-gradient-to-b from-[var(--cane-400)] to-gray-300 mt-2 min-h-[40px]" id="connector-tillering"></div>
                </div>
                <div class="flex-1 pt-0.5">
                  <div class="flex items-center justify-between mb-2">
              <div>
                      <p class="font-semibold text-sm">Tillering</p>
                      <p class="text-xs text-gray-600" id="tlTill">0% Complete - Expected</p>
              </div>
                    <span class="badge badge-progress text-xs" id="badge-tillering" style="display: none;">In Progress</span>
            </div>
                  <div id="activities-tillering" class="mt-3 space-y-2 activities-stage-list">
                    <!-- Activity records for this stage will be inserted here -->
            </div>
                </div>
              </div>
            </div>

            <!-- Grand Growth Stage -->
            <div class="timeline-stage" data-stage="Grand Growth">
              <div class="flex items-start gap-3 pb-4">
                <div class="flex flex-col items-center">
                  <div class="w-4 h-4 rounded-full bg-gray-300 border-2 border-white shadow-md stage-indicator" id="stage-grand"></div>
                  <div class="w-0.5 h-full bg-gradient-to-b from-gray-300 to-gray-300 mt-2 min-h-[40px]" id="connector-grand"></div>
                </div>
                <div class="flex-1 pt-0.5">
                  <div class="flex items-center justify-between mb-2">
              <div>
                      <p class="font-semibold text-sm">Grand Growth</p>
                      <p class="text-xs text-gray-600" id="tlGrand">Status: -</p>
              </div>
                    <span class="badge badge-not text-xs" id="badge-grand" style="display: none;">Expected</span>
            </div>
                  <div id="activities-grand" class="mt-3 space-y-2 activities-stage-list">
                    <!-- Activity records for this stage will be inserted here -->
                  </div>
                </div>
              </div>
            </div>

            <!-- Maturing / Ripening Stage -->
            <div class="timeline-stage" data-stage="Maturing / Ripening">
              <div class="flex items-start gap-3 pb-4">
                <div class="flex flex-col items-center">
                  <div class="w-4 h-4 rounded-full bg-gray-300 border-2 border-white shadow-md stage-indicator" id="stage-maturing"></div>
                  <div class="w-0.5 h-full bg-gradient-to-b from-gray-300 to-gray-300 mt-2 min-h-[40px]" id="connector-maturing"></div>
                </div>
                <div class="flex-1 pt-0.5">
                  <div class="flex items-center justify-between mb-2">
              <div>
                      <p class="font-semibold text-sm">Maturing / Ripening</p>
                      <p class="text-xs text-gray-600" id="tlMat">Status: -</p>
              </div>
                    <span class="badge badge-not text-xs" id="badge-maturing" style="display: none;">Expected</span>
            </div>
                  <div id="activities-maturing" class="mt-3 space-y-2 activities-stage-list">
                    <!-- Activity records for this stage will be inserted here -->
                  </div>
                </div>
              </div>
            </div>

            <!-- Harvest Stage -->
            <div class="timeline-stage" data-stage="Harvest">
              <div class="flex items-start gap-3">
                <div class="flex flex-col items-center">
                  <div class="w-4 h-4 rounded-full bg-gray-300 border-2 border-white shadow-md stage-indicator" id="stage-harvest"></div>
                </div>
                <div class="flex-1 pt-0.5">
                  <div class="flex items-center justify-between mb-2">
                    <div>
                      <p class="font-semibold text-sm">Harvest</p>
                      <p class="text-xs text-gray-600">Final Stage</p>
                    </div>
                    <span class="badge badge-not text-xs" id="badge-harvest" style="display: none;">Expected</span>
                  </div>
                  <div id="activities-harvest" class="mt-3 space-y-2 activities-stage-list">
                    <!-- Activity records for this stage will be inserted here -->
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Empty state message -->
          <div id="timelineEmptyState" class="hidden text-center py-8">
            <i class="fas fa-seedling text-4xl text-gray-300 mb-3"></i>
            <p class="text-sm text-gray-500">No activity records yet. Submit your first input record to see it here.</p>
          </div>
        </div>

        <!-- Predicted Harvest Modal (floating) -->
        <div id="predictedHarvestModal" class="section-card rounded-xl p-4 hidden" style="position: sticky; top: 20px;">
          <div class="flex items-center justify-between mb-3">
            <h3 class="font-semibold text-sm flex items-center gap-2">
              <i class="fas fa-calendar-alt text-[var(--cane-700)]"></i>
              Predicted Harvest
            </h3>
            <button id="closePredictedHarvest" class="text-gray-500 hover:text-gray-700">
              <i class="fas fa-times"></i>
            </button>
          </div>
          <div id="predictedHarvestContent" class="text-sm space-y-2">
            <!-- Predicted harvest info will be displayed here -->
          </div>
        </div>

        <!-- ‚úÖ Historical Planting & Harvest Data -->
        <div id="historicalDataSection" class="section-card rounded-xl p-4" style="display: none;">
          <div class="flex items-center justify-between mb-4">
            <p class="font-semibold text-sm flex items-center gap-2">
              <i class="fas fa-history text-[var(--cane-700)]"></i>
              Previous Cycles History
            </p>
            <button id="toggleHistoryBtn"
              class="text-xs text-[var(--cane-700)] hover:text-[var(--cane-800)] font-medium">
              <i class="fas fa-chevron-up"></i> Collapse
            </button>
          </div>
          <div id="historicalDataContent" class="space-y-3">
            <!-- Historical data will be populated here -->
          </div>
        </div>
      </section>
      <div id="pdfTimestamp" class="text-[10px] text-gray-600 mt-8 mb-4">
        Generated on: <span id="generatedStamp"></span>
      </div>

      <!-- Record Detail Modal -->
      <div id="recordDetailModal" class="fixed inset-0 flex items-center justify-center bg-black/50 backdrop-blur-sm hidden z-50 p-4 animate-fadeIn">
        <div class="bg-white rounded-2xl w-full max-w-5xl max-h-[92vh] overflow-hidden flex flex-col shadow-2xl transform transition-all">
          <!-- Modal Header -->
          <div class="px-6 py-5 border-b border-gray-200 bg-gradient-to-r from-[var(--cane-50)] to-white flex items-center justify-between">
            <div class="flex items-center gap-3">
              <div class="w-10 h-10 rounded-lg bg-[var(--cane-600)] flex items-center justify-center">
                <i class="fas fa-file-alt text-white text-lg"></i>
              </div>
              <div>
                <h3 class="text-xl font-bold text-gray-900">Record Details</h3>
                <p class="text-xs text-gray-500 mt-0.5">View complete record information</p>
              </div>
            </div>
            <button id="closeRecordModal" class="w-9 h-9 rounded-lg text-gray-500 hover:text-gray-700 hover:bg-gray-100 flex items-center justify-center transition-colors">
              <i class="fas fa-times text-lg"></i>
            </button>
          </div>
          <!-- Modal Content -->
          <div id="recordDetailContent" class="px-6 py-6 overflow-y-auto flex-1 bg-gray-50">
            <!-- Record details will be rendered here -->
          </div>
        </div>
      </div>


      <script type="module">
        import { auth, db } from '../../backend/Common/firebase-config.js';
        import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js';
        import { collection, query, where, getDocs, onSnapshot, getDoc, doc, orderBy, Timestamp } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js';
        import { getFieldGrowthData, calculateDAP, getGrowthStage, calculateDaysRemaining, VARIETY_HARVEST_DAYS, handleRatooning, calculateRatoonExpectedHarvestDate } from '../../backend/Handler/growth-tracker.js';
        import { updateDoc } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js';

        let currentUserId = null;
        let userFields = [];
        let selectedFieldId = null;
        let recordsUnsubscribe = null; // Store unsubscribe function for real-time listener
        
        // Expose selectedFieldId globally for button handlers
        window.selectedFieldIdRef = { value: null };

        // Ratoon duration mapping (in months) for each variety
        // These are the ratoon-specific maturity months (different from initial planting)
        const RATOON_DURATIONS = {
          'K 88-65': { min: 11, max: 13 },
          'K 88-87': { min: 11, max: 13 },
          'PS 1': { min: 10, max: 11 },
          'VMC 84-947': { min: 10, max: 11 },
          'PS 2': { min: 8, max: 9 },
          'VMC 88-354': { min: 8, max: 9 },
          'PS 3': { min: 9, max: 10 },
          'VMC 84-524': { min: 9, max: 10 },
          'CADP Sc1': { min: 9, max: 10 },
          'PS 4': { min: 9, max: 11 },
          'VMC 95-152': { min: 9, max: 11 },
          'PS 5': { min: 9, max: 11 },
          'VMC 95-09': { min: 9, max: 11 },
          'PSR 2000-161': { min: 10, max: 11 },
          'PSR 2000-343': { min: 10, max: 11 },
          'PSR 2000-34': { min: 10, max: 11 },
          'PSR 97-41': { min: 10, max: 10 },
          'PSR 97-45': { min: 9, max: 10 },
          'PS 862': { min: 9, max: 11 },
          'VMC 71-39': { min: 9, max: 11 },
          'VMC 84-549': { min: 9, max: 9 },
          'VMC 86-550': { min: 10, max: 11 },
          'VMC 87-599': { min: 9, max: 11 },
          'VMC 87-95': { min: 9, max: 10 }
        };

        // Variety months-to-harvest mapping for expected harvest date calculation
        const VARIETY_HARVEST_MONTHS = {
          'K 88-65': { min: 12, max: 14 },
          'K 88-87': { min: 12, max: 14 },
          'PS 1': { min: 11, max: 12 },
          'VMC 84-947': { min: 11, max: 12 },
          'PS 2': { min: 9, max: 10 },
          'VMC 88-354': { min: 9, max: 10 },
          'PS 3': { min: 10, max: 11 },
          'VMC 84-524': { min: 10, max: 11 },
          'CADP Sc1': { min: 10, max: 11 },
          'PS 4': { min: 10, max: 12 },
          'VMC 95-152': { min: 10, max: 12 },
          'PS 5': { min: 10, max: 12 },
          'VMC 95-09': { min: 10, max: 12 },
          'PSR 2000-161': { min: 11, max: 12 },
          'PSR 2000-343': { min: 11, max: 11.5 },
          'PSR 2000-34': { min: 11, max: 12 },
          'PSR 97-41': { min: 11, max: 11 },
          'PSR 97-45': { min: 10, max: 11 },
          'Ps 862': { min: 10, max: 12 },
          'VMC 71-39': { min: 10, max: 12 },
          'VMC 84-549': { min: 10, max: 10 },
          'VMC 86-550': { min: 11, max: 12 },
          'VMC 87-599': { min: 10, max: 12 },
          'VMC 87-95': { min: 10, max: 11 }
        };

        // DAP (Days After Planting) stage ranges for each variety
        const DAP_STAGE_RANGES = {
          'K 88-65': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 130 },
            'Grand Growth': { min: 130, max: 300 },
            Maturity: { min: 300, max: 420 }
          },
          'K 88-87': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 130 },
            'Grand Growth': { min: 130, max: 300 },
            Maturity: { min: 300, max: 420 }
          },
          'PS 1': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 270 },
            Maturity: { min: 270, max: 360 }
          },
          'VMC 84-947': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 270 },
            Maturity: { min: 270, max: 360 }
          },
          'PS 2': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 100 },
            'Grand Growth': { min: 100, max: 240 },
            Maturity: { min: 240, max: 300 }
          },
          'VMC 88-354': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 100 },
            'Grand Growth': { min: 100, max: 240 },
            Maturity: { min: 240, max: 300 }
          },
          'PS 3': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 110 },
            'Grand Growth': { min: 110, max: 260 },
            Maturity: { min: 260, max: 330 }
          },
          'VMC 84-524': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 110 },
            'Grand Growth': { min: 110, max: 260 },
            Maturity: { min: 260, max: 330 }
          },
          'CADP Sc1': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 110 },
            'Grand Growth': { min: 110, max: 260 },
            Maturity: { min: 260, max: 330 }
          },
          'PS 4': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 280 },
            Maturity: { min: 280, max: 360 }
          },
          'VMC 95-152': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 280 },
            Maturity: { min: 280, max: 360 }
          },
          'PS 5': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 280 },
            Maturity: { min: 280, max: 360 }
          },
          'VMC 95-09': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 280 },
            Maturity: { min: 280, max: 360 }
          },
          'PSR 2000-161': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 270 },
            Maturity: { min: 270, max: 360 }
          },
          'PSR 2000-343': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 260 },
            Maturity: { min: 260, max: 350 }
          },
          'PSR 2000-34': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 270 },
            Maturity: { min: 270, max: 360 }
          },
          'PSR 97-41': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 110 },
            'Grand Growth': { min: 110, max: 250 },
            Maturity: { min: 250, max: 330 }
          },
          'PSR 97-45': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 110 },
            'Grand Growth': { min: 110, max: 250 },
            Maturity: { min: 250, max: 330 }
          },
          'Ps 862': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 280 },
            Maturity: { min: 280, max: 360 }
          },
          'VMC 71-39': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 280 },
            Maturity: { min: 280, max: 360 }
          },
          'VMC 84-549': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 100 },
            'Grand Growth': { min: 100, max: 240 },
            Maturity: { min: 240, max: 300 }
          },
          'VMC 86-550': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 270 },
            Maturity: { min: 270, max: 360 }
          },
          'VMC 87-599': {
            Germination: { min: 0, max: 35 },
            Tillering: { min: 35, max: 120 },
            'Grand Growth': { min: 120, max: 280 },
            Maturity: { min: 280, max: 360 }
          },
          'VMC 87-95': {
            Germination: { min: 0, max: 30 },
            Tillering: { min: 30, max: 110 },
            'Grand Growth': { min: 110, max: 250 },
            Maturity: { min: 250, max: 330 }
          }
        };

        // Auth state listener
        onAuthStateChanged(auth, async (user) => {
          if (user) {
            currentUserId = user.uid;
            await loadUserFields();
          } else {
            window.location.href = '../Common/farmers_login.html';
          }
        });

        // Get fieldId from URL parameters
        function getFieldIdFromURL() {
          const urlParams = new URLSearchParams(window.location.search);
          return urlParams.get('fieldId');
        }

        // Load user's fields (all fields, same as Input Records)
        async function loadUserFields() {
          try {
            if (!currentUserId) {
              console.error('‚ùå No currentUserId available');
              return;
            }

            // Load ALL fields for the user (no status filter, same as Input Records)
            // This ensures handlers see all their fields regardless of status
            const fieldsQuery = query(
              collection(db, 'fields'),
              where('userId', '==', currentUserId)
            );

            const snapshot = await getDocs(fieldsQuery);
            userFields = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            console.log(`üìã Loaded ${userFields.length} fields for handler (userId: ${currentUserId})`);
            console.log('üìã Field details:', userFields.map(f => ({ 
              id: f.id, 
              name: f.field_name || f.fieldName || 'Unnamed',
              status: f.status 
            })));

            // Always populate dropdown with ALL fields first
            populateFieldDropdown();

            if (userFields.length > 0) {
              // Check if fieldId is in URL (from success banner redirect)
              const urlFieldId = getFieldIdFromURL();
              
              if (urlFieldId) {
                // Auto-select field from URL parameter
                const fieldExists = userFields.find(f => f.id === urlFieldId);
                if (fieldExists) {
                  selectedFieldId = urlFieldId;
                  if (window.selectedFieldIdRef) window.selectedFieldIdRef.value = urlFieldId;
                  console.log(`üìç Auto-selecting field from URL: ${urlFieldId}`);
                  
                  // Update native select
                  const fieldSelect = document.getElementById('gtField');
                  if (fieldSelect) {
                    fieldSelect.value = urlFieldId;
                  }
                  
                  // Update custom dropdown trigger text
                  const dropdownTriggerText = document.getElementById('dropdownTriggerText');
                  if (dropdownTriggerText) {
                    dropdownTriggerText.textContent = fieldExists.field_name || fieldExists.fieldName || 'Unnamed Field';
                  }
                  
                  // Update selected state in custom dropdown options
                  document.querySelectorAll('.dropdown-option').forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.dataset.value === urlFieldId) {
                      opt.classList.add('selected');
                    }
                  });
                  
                  // Load field data
                  await displayFieldGrowthData(selectedFieldId);
                  
                  // Clean up URL parameter (keeps URL clean after auto-selection)
                  const newUrl = window.location.pathname;
                  window.history.replaceState({}, '', newUrl);
                } else {
                  console.warn(`‚ö†Ô∏è Field ${urlFieldId} not found in handler's fields`);
                  // Fallback to first field if URL fieldId doesn't exist
              selectedFieldId = userFields[0].id;
              if (window.selectedFieldIdRef) window.selectedFieldIdRef.value = selectedFieldId;
              await displayFieldGrowthData(selectedFieldId);
                }
              } else {
                // Normal navigation (no URL parameter) - select first field
                selectedFieldId = userFields[0].id;
                if (window.selectedFieldIdRef) window.selectedFieldIdRef.value = selectedFieldId;
                
                // Ensure dropdowns are set to first field
                const fieldSelect = document.getElementById('gtField');
                if (fieldSelect) {
                  fieldSelect.value = selectedFieldId;
                }
                
                const dropdownTriggerText = document.getElementById('dropdownTriggerText');
                const firstField = userFields[0];
                if (dropdownTriggerText && firstField) {
                  dropdownTriggerText.textContent = firstField.field_name || firstField.fieldName || 'Unnamed Field';
                }
                
                // Update selected state in custom dropdown
                document.querySelectorAll('.dropdown-option').forEach((opt, index) => {
                  opt.classList.remove('selected');
                  if (index === 0) {
                    opt.classList.add('selected');
                  }
                });
                
                await displayFieldGrowthData(selectedFieldId);
              }
            } else {
              showNoFieldsMessage();
            }

          } catch (error) {
            console.error('Error loading fields:', error);
            showError('Failed to load fields. Please try again.');
          }
        }

        // Populate field dropdown (both native and custom)
        // This function ALWAYS shows ALL fields - selection logic is handled separately
        function populateFieldDropdown() {
          const fieldSelect = document.getElementById('gtField');
          const dropdownOptions = document.getElementById('dropdownOptions');
          const dropdownTrigger = document.getElementById('dropdownTrigger');
          const dropdownTriggerText = document.getElementById('dropdownTriggerText');

          if (!fieldSelect) {
            console.error('‚ùå Field select element not found');
            return;
          }

          console.log(`üîÑ Populating dropdown with ${userFields.length} fields`);

          // Clear existing options
          fieldSelect.innerHTML = '';
          if (dropdownOptions) dropdownOptions.innerHTML = '';

          if (userFields.length === 0) {
            console.warn('‚ö†Ô∏è No fields available to populate');
            fieldSelect.innerHTML = '<option>No fields available</option>';
            fieldSelect.disabled = true;
            if (dropdownTriggerText) dropdownTriggerText.textContent = 'No fields available';
            return;
          }

          // Populate native select with ALL fields
          userFields.forEach((field, index) => {
            const option = document.createElement('option');
            option.value = field.id;
            const fieldName = field.field_name || field.fieldName || 'Unnamed Field';
            option.textContent = fieldName;
            fieldSelect.appendChild(option);
            console.log(`  ‚úì Added field ${index + 1}: ${fieldName} (${field.id})`);
          });

          // Populate custom dropdown with ALL fields
          if (dropdownOptions) {
            userFields.forEach((field, index) => {
              const optionBtn = document.createElement('button');
              optionBtn.type = 'button';
              // Don't set selected state here - it will be set by loadUserFields after checking URL
              optionBtn.className = 'dropdown-option';
              optionBtn.textContent = field.field_name || field.fieldName || 'Unnamed Field';
              optionBtn.dataset.value = field.id;

              optionBtn.addEventListener('click', async () => {
                try {
                selectedFieldId = field.id;
                if (window.selectedFieldIdRef) window.selectedFieldIdRef.value = selectedFieldId;
                  
                  // Update native select
                  if (fieldSelect) {
                    fieldSelect.value = selectedFieldId;
                  }
                  
                  // Update custom dropdown trigger text
                  if (dropdownTriggerText) {
                dropdownTriggerText.textContent = field.field_name || field.fieldName || 'Unnamed Field';
                  }

                // Update selected state
                document.querySelectorAll('.dropdown-option').forEach(opt => opt.classList.remove('selected'));
                optionBtn.classList.add('selected');

                // Close dropdown
                closeDropdown();

                  // Unsubscribe from previous field's listener
                  if (recordsUnsubscribe) {
                    recordsUnsubscribe();
                    recordsUnsubscribe = null;
                  }

                // Load data
                await displayFieldGrowthData(selectedFieldId);
                } catch (error) {
                  console.error('Error selecting field:', error);
                  showError('Failed to load field data. Please try again.');
                }
              });

              dropdownOptions.appendChild(optionBtn);
            });
          }

          // Native select change handler
          fieldSelect.addEventListener('change', async (e) => {
            try {
            selectedFieldId = e.target.value;
            if (window.selectedFieldIdRef) window.selectedFieldIdRef.value = selectedFieldId;
              if (!selectedFieldId) return;
              
            const selectedField = userFields.find(f => f.id === selectedFieldId);
            if (dropdownTriggerText && selectedField) {
              dropdownTriggerText.textContent = selectedField.field_name || selectedField.fieldName || 'Unnamed Field';
            }
              
              // Unsubscribe from previous field's listener
              if (recordsUnsubscribe) {
                recordsUnsubscribe();
                recordsUnsubscribe = null;
              }
              
            await displayFieldGrowthData(selectedFieldId);
            } catch (error) {
              console.error('Error changing field:', error);
              showError('Failed to load field data. Please try again.');
            }
          });
        }

        // Custom dropdown functions
        function openDropdown() {
          const dropdownMenu = document.getElementById('dropdownMenu');
          const dropdownTrigger = document.getElementById('dropdownTrigger');
          if (dropdownMenu) dropdownMenu.classList.add('open');
          if (dropdownTrigger) dropdownTrigger.classList.add('open');
        }

        function closeDropdown() {
          const dropdownMenu = document.getElementById('dropdownMenu');
          const dropdownTrigger = document.getElementById('dropdownTrigger');
          if (dropdownMenu) dropdownMenu.classList.remove('open');
          if (dropdownTrigger) dropdownTrigger.classList.remove('open');
        }

        // Dropdown event listeners
        document.addEventListener('DOMContentLoaded', () => {
          const dropdownTrigger = document.getElementById('dropdownTrigger');
          const dropdownMenu = document.getElementById('dropdownMenu');

          if (dropdownTrigger) {
            dropdownTrigger.addEventListener('click', (e) => {
              e.stopPropagation();
              const isOpen = dropdownMenu?.classList.contains('open');
              if (isOpen) {
                closeDropdown();
              } else {
                openDropdown();
              }
            });
          }

          // Close dropdown when clicking outside
          document.addEventListener('click', (e) => {
            const dropdown = document.querySelector('.custom-dropdown');
            if (dropdown && !dropdown.contains(e.target)) {
              closeDropdown();
            }
          });

          // Close dropdown when pressing Escape
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
              closeDropdown();
            }
          });
        });

        // Display field growth data
        async function displayFieldGrowthData(fieldId) {
          if (!fieldId) {
            console.error('No fieldId provided to displayFieldGrowthData');
            return;
          }

          try {
            const growthData = await getFieldGrowthData(fieldId);


            // Update field title
            const selectedField = userFields.find(f => f.id === fieldId);
            const fieldName = selectedField?.field_name || selectedField?.fieldName || 'Field';

            window.latestGrowthData = growthData;
            window.latestFieldName = fieldName;

            const fieldStatusTitle = document.getElementById('fieldStatusTitle');
            if (fieldStatusTitle) {
              fieldStatusTitle.textContent = `${fieldName} - Growth Status`;
            }

            // Update variety display
            const uiVariety = document.getElementById('uiVariety');
            if (uiVariety) {
              uiVariety.textContent = growthData.variety || 'Not specified';
            }

            // Update fertilizers used
            const uiFertilizers = document.getElementById('uiFertilizers');
            if (uiFertilizers) {
              uiFertilizers.textContent = growthData.fertilizersUsed || '‚Äî';
            }

            // Update seed rate
            const uiSeedRate = document.getElementById('uiSeedRate');
            if (uiSeedRate) {
              if (growthData.seedRate) {
                // Format seed rate with units if it's a number
                const seedRateValue = typeof growthData.seedRate === 'number' 
                  ? growthData.seedRate.toLocaleString('en-US', { maximumFractionDigits: 2 })
                  : growthData.seedRate;
                uiSeedRate.textContent = seedRateValue;
              } else {
                uiSeedRate.textContent = '‚Äî';
              }
            }

            // Update area size
            const uiAreaSize = document.getElementById('uiAreaSize');
            if (uiAreaSize) {
              const areaValue = growthData.area || growthData.field_size || growthData.area_size || growthData.size;
              uiAreaSize.textContent = areaValue ? `${areaValue} ha` : '‚Äî';
            }

            // CRITICAL: Check if field has been planted FIRST
            // All growth-related data (DAP, stage, progress, harvest) requires planting
            // This check happens early to prevent any growth data from being displayed
            if (!growthData.plantingDate) {
              // No planting - show not planted state and reset all growth UI
              showNotPlantedState();
              resetTimeline();
              // Hide predicted harvest modal
              document.getElementById('predictedHarvestModal')?.classList.add('hidden');
              // Still load timeline nodes to show all submitted reports (without DAP/stage mapping)
              await loadTimelineNodes(fieldId);
              // Update ratoon button state (works for both planted and unplanted fields)
              updateRatoonButtonState(growthData);
              return;
            }

            // Remove "not planted" message if it exists
            const notPlantedMsg = document.getElementById('notPlantedInfo');
            if (notPlantedMsg) notPlantedMsg.remove();

            // CRITICAL: All growth-related data (DAP, stage, progress, harvest) 
            // MUST only be displayed when planting exists
            // Planting record is the single source of truth for ALL growth tracking
            const plantingDate = growthData.plantingDate;

            // Planting exists - update ALL growth-related data
            // Update planting date display
            const uiPlanted = document.getElementById('uiPlanted');
            if (uiPlanted && plantingDate) {
              uiPlanted.textContent = plantingDate.toLocaleDateString();
            }

            // Update planted date display in header
            const plantedDateDisplay = document.getElementById('plantedDateDisplay');
            if (plantedDateDisplay && plantingDate) {
              plantedDateDisplay.textContent = plantingDate.toLocaleDateString();
            }

            // Update DAP (only when planting exists)
            const uiDays = document.getElementById('uiDays');
            if (uiDays) {
              uiDays.textContent = growthData.DAP !== null ? growthData.DAP.toString() : '0';
            }

            // Update current growth stage (only when planting exists)
            const uiStage = document.getElementById('uiStage');
            if (uiStage) {
              uiStage.textContent = growthData.currentGrowthStage || '‚Äî';
            }

            // Update expected harvest date (only when planting exists)
            const uiHarvest = document.getElementById('uiHarvest');
            if (uiHarvest) {
              // Use formatted string if available (shows range), otherwise format the date
              if (growthData.expectedHarvestDateFormatted) {
                uiHarvest.textContent = growthData.expectedHarvestDateFormatted;
              } else if (growthData.expectedHarvestDate) {
                uiHarvest.textContent = growthData.expectedHarvestDate.toLocaleDateString();
              } else {
                uiHarvest.textContent = '‚Äî';
              }
            }

            // Update days remaining (only when planting exists)
            const uiRemain = document.getElementById('uiRemain');
            const uiMonths = document.getElementById('uiMonths');
            if (uiRemain && uiMonths) {
              if (growthData.daysRemaining !== null) {
                uiRemain.textContent = Math.max(0, growthData.daysRemaining).toString();
                uiMonths.textContent = Math.max(0, Math.round(growthData.daysRemaining / 30.5)).toString();
              } else {
                uiRemain.textContent = '‚Äî';
                uiMonths.textContent = '‚Äî';
              }
            }

            // CRITICAL: Update timeline progress and all growth-related features
            // All of these require planting to exist
            // Update timeline progress (this will update stage indicators and progress bar)
            updateTimeline(growthData);

            // Show warnings for delays or overdue harvest
            showWarnings(growthData);

            // ‚úÖ Display historical planting & harvest data
            await displayHistoricalData(fieldId);

            // ‚úÖ Load and display timeline nodes (integrated into stages)
            await loadTimelineNodes(fieldId);

            // ‚úÖ Check and display predicted harvest
            await checkPredictedHarvest(fieldId);

            // Update ratoon button state (works for both planted and unplanted fields)
            updateRatoonButtonState(growthData);

          } catch (error) {
            console.error('Error displaying field growth data:', error);
            showError('Failed to load growth tracking data.');
          }
        }

        // Expose functions globally for button handlers
        window.displayFieldGrowthData = displayFieldGrowthData;
        window.loadTimelineNodes = loadTimelineNodes;

        // Reset timeline to empty state
        function resetTimeline() {
          const tlBar = document.getElementById('tlBar');
          const tlPct = document.getElementById('tlPct');
          const progressPercentage = document.getElementById('progressPercentage');
          const progressCurrent = document.getElementById('progressCurrent');
          const tlGerm = document.getElementById('tlGerm');
          const tlTill = document.getElementById('tlTill');
          const tlGrand = document.getElementById('tlGrand');
          const tlMat = document.getElementById('tlMat');

          if (tlBar) tlBar.style.width = '0%';
          if (tlPct) tlPct.textContent = '0';
          if (progressPercentage) progressPercentage.textContent = '0%';
          if (progressCurrent) progressCurrent.textContent = 'Not Planted';
          if (tlGerm) tlGerm.textContent = 'Status: Not Planted';
          if (tlTill) tlTill.textContent = 'Status: Not Planted';
          if (tlGrand) tlGrand.textContent = 'Status: Not Planted';
          if (tlMat) tlMat.textContent = 'Status: Not Planted';

          // Reset all stage indicators
          const stages = ['germination', 'tillering', 'grand', 'maturing', 'harvest'];
          stages.forEach(stage => {
            const indicator = document.getElementById(`stage-${stage}`);
            const badge = document.getElementById(`badge-${stage}`);
            const connector = document.getElementById(`connector-${stage}`);
            if (indicator) {
              indicator.classList.remove('active', 'completed', 'in-progress');
            }
            if (badge) badge.style.display = 'none';
            if (connector) {
              connector.className = 'w-0.5 h-full bg-gradient-to-b from-gray-300 to-gray-300 mt-2 min-h-[40px]';
            }
          });
        }

        // Update timeline with progress
        function updateTimeline(growthData) {
          // CRITICAL: Do not update timeline if no planting date exists
          if (!growthData.plantingDate) {
            resetTimeline();
            return;
          }

          const DAP = growthData.DAP || 0;
          const variety = growthData.variety || '';
          const totalDays = VARIETY_HARVEST_DAYS[variety] || 365;

          // Update progress bar
          const progress = Math.min(100, Math.round((DAP / totalDays) * 100));
          const tlBar = document.getElementById('tlBar');
          const tlPct = document.getElementById('tlPct');
          const progressPercentage = document.getElementById('progressPercentage');
          const progressCurrent = document.getElementById('progressCurrent');

          if (tlBar) tlBar.style.width = progress + '%';
          if (tlPct) tlPct.textContent = progress.toString();
          if (progressPercentage) progressPercentage.textContent = progress + '%';
          if (progressCurrent) progressCurrent.textContent = growthData.currentGrowthStage || '‚Äî';

          // Calculate stage percentages based on DAP and variety-specific ranges
          const stageProgress = getAllStageProgress(variety, DAP);

          // Update timeline labels and stage indicators with percentages
          const plantingDate = growthData.plantingDate;
          const currentStage = growthData.currentGrowthStage || 'Not Planted';

          // Ensure plantingDate is a valid Date object
          if (!(plantingDate instanceof Date)) {
            console.error('Invalid planting date in updateTimeline:', plantingDate);
            resetTimeline();
            return;
          }

          // Get variety-specific DAP ranges
          const stageRanges = DAP_STAGE_RANGES[variety] || {};
          const germRange = stageRanges.Germination || { min: 0, max: 35 };
          const tillRange = stageRanges.Tillering || { min: 35, max: 120 };
          const grandRange = stageRanges['Grand Growth'] || { min: 120, max: 280 };
          const matRange = stageRanges.Maturity || { min: 280, max: 360 };

          // Calculate end dates based on variety-specific ranges
          const germEnd = new Date(plantingDate.getTime() + germRange.max * 24 * 60 * 60 * 1000);
          const tillEnd = new Date(plantingDate.getTime() + tillRange.max * 24 * 60 * 60 * 1000);
          const grandEnd = new Date(plantingDate.getTime() + grandRange.max * 24 * 60 * 60 * 1000);
          const matEnd = new Date(plantingDate.getTime() + matRange.max * 24 * 60 * 60 * 1000);

          // Update status text with percentages
          const tlGerm = document.getElementById('tlGerm');
          const tlTill = document.getElementById('tlTill');
          const tlGrand = document.getElementById('tlGrand');
          const tlMat = document.getElementById('tlMat');

          // Helper function to determine status based on DAP and range
          function getStageStatus(DAP, range, isInRange) {
            if (DAP >= range.max) return 'Completed';
            if (isInRange) return 'In Progress';
            if (DAP < range.min) return 'Expected';
            return 'Active';
          }

          // Update Germination stage
          if (tlGerm) {
            const germPercent = stageProgress.Germination || 0;
            const isInGermRange = DAP >= germRange.min && DAP < germRange.max;
            const status = getStageStatus(DAP, germRange, isInGermRange);
            tlGerm.textContent = `${germPercent}% Complete - ${status}`;
          }

          // Update Tillering stage
          if (tlTill) {
            const tillPercent = stageProgress.Tillering || 0;
            const isInTillRange = DAP >= tillRange.min && DAP < tillRange.max;
            const status = getStageStatus(DAP, tillRange, isInTillRange);
            // Remove any existing percentage spans to avoid duplicates
            const existingSpans = tlTill.querySelectorAll('span');
            existingSpans.forEach(span => {
              if (span.id === 'tlPct' || span.classList.contains('stage-percent')) {
                span.remove();
              }
            });
            tlTill.innerHTML = `<span class="stage-percent font-semibold">${tillPercent}%</span> Complete - ${status}`;
          }

          // Update Grand Growth stage
          if (tlGrand) {
            const grandPercent = stageProgress['Grand Growth'] || 0;
            const isInGrandRange = DAP >= grandRange.min && DAP < grandRange.max;
            const status = getStageStatus(DAP, grandRange, isInGrandRange);
            tlGrand.textContent = `${grandPercent}% Complete - ${status}`;
          }

          // Update Maturity/Ripening stage
          if (tlMat) {
            const matPercent = stageProgress.Maturity || 0;
            const isInMatRange = DAP >= matRange.min && DAP < matRange.max;
            const status = getStageStatus(DAP, matRange, isInMatRange);
            tlMat.textContent = `${matPercent}% Complete - ${status}`;
          }

          // Update stage indicators and badges
          updateStageIndicators(DAP, currentStage);
        }

        // Update stage visual indicators based on DAP and current stage
        function updateStageIndicators(DAP, currentStage) {
          // Normalize current stage name
          const normalizedStage = currentStage?.replace('Stage', '').trim() || '';
          
          const stages = [
            { name: 'Germination', threshold: 45, element: 'germination', startDAP: 0 },
            { name: 'Tillering', threshold: 100, element: 'tillering', startDAP: 45 },
            { name: 'Grand Growth', threshold: 240, element: 'grand', startDAP: 100 },
            { name: 'Maturing / Ripening', threshold: 300, element: 'maturing', startDAP: 240 },
            { name: 'Harvest', threshold: 365, element: 'harvest', startDAP: 300 }
          ];

          stages.forEach((stage, index) => {
            const indicator = document.getElementById(`stage-${stage.element}`);
            const badge = document.getElementById(`badge-${stage.element}`);
            const connector = document.getElementById(`connector-${stage.element}`);

            if (!indicator) return;

            // Reset classes
            indicator.classList.remove('active', 'completed', 'in-progress');
            if (badge) badge.style.display = 'none';

            // Determine stage state based on DAP ranges
            const isCompleted = DAP >= stage.threshold;
            const isCurrent = (DAP >= stage.startDAP && DAP < stage.threshold) || 
                             normalizedStage.toLowerCase().includes(stage.name.toLowerCase()) ||
                             (stage.name === 'Germination' && (normalizedStage === 'Germination' || DAP < 45)) ||
                             (stage.name === 'Tillering' && (normalizedStage === 'Tillering' || (DAP >= 45 && DAP < 100))) ||
                             (stage.name === 'Grand Growth' && (normalizedStage.includes('Grand') || (DAP >= 100 && DAP < 240))) ||
                             (stage.name === 'Maturing / Ripening' && (normalizedStage.includes('Matur') || normalizedStage.includes('Ripen') || (DAP >= 240 && DAP < 300))) ||
                             (stage.name === 'Harvest' && (normalizedStage.includes('Harvest') || DAP >= 300));

            // Update previous stages to completed
            if (index > 0) {
              const prevStage = stages[index - 1];
              if (DAP >= prevStage.threshold) {
                const prevIndicator = document.getElementById(`stage-${prevStage.element}`);
                const prevBadge = document.getElementById(`badge-${prevStage.element}`);
                const prevConnector = document.getElementById(`connector-${prevStage.element}`);
                
                if (prevIndicator) prevIndicator.classList.add('completed');
                if (prevBadge) {
                  prevBadge.textContent = 'Completed';
                  prevBadge.className = 'badge badge-done text-xs';
                  prevBadge.style.display = 'inline-block';
                }
                if (prevConnector) {
                  prevConnector.className = 'w-0.5 h-full bg-gradient-to-b from-[var(--cane-600)] to-[var(--cane-400)] mt-2 min-h-[40px]';
                }
              }
            }

            if (isCompleted) {
              indicator.classList.add('completed');
              if (badge) {
                badge.textContent = 'Completed';
                badge.className = 'badge badge-done text-xs';
                badge.style.display = 'inline-block';
              }
              if (connector) {
                connector.className = 'w-0.5 h-full bg-gradient-to-b from-[var(--cane-600)] to-[var(--cane-400)] mt-2 min-h-[40px]';
              }
            } else if (isCurrent) {
              indicator.classList.add('active', 'in-progress');
              if (badge) {
                badge.textContent = 'In Progress';
                badge.className = 'badge badge-progress text-xs';
                badge.style.display = 'inline-block';
              }
              if (connector && index < stages.length - 1) {
                connector.className = 'w-0.5 h-full bg-gradient-to-b from-[var(--cane-400)] to-gray-300 mt-2 min-h-[40px]';
              }
            }
          });
        }

        // Get current growth stage based on DAP and variety
        function getGrowthStageByDAP(variety, DAP) {
          const stageRanges = DAP_STAGE_RANGES[variety];
          if (!stageRanges) return 'Unknown';
          for (const [stageName, range] of Object.entries(stageRanges)) {
            if (DAP >= range.min && DAP <= range.max) return stageName;
          }
          return 'Maturity';
        }

        // Get stage completion percentage
        function getStageCompletionPercentage(variety, DAP) {
          const stageRanges = DAP_STAGE_RANGES[variety];
          if (!stageRanges) return 0;
          for (const [stageName, range] of Object.entries(stageRanges)) {
            if (DAP >= range.min && DAP <= range.max) {
              const stageDuration = range.max - range.min;
              const daysIntoStage = DAP - range.min;
              return Math.round((daysIntoStage / stageDuration) * 100);
            }
          }
          return 100;
        }

        // Get all stage progress for a variety based on DAP
        // Returns percentages for each stage: Germination, Tillering, Grand Growth, Maturity
        function getAllStageProgress(variety, DAP) {
          const stageRanges = DAP_STAGE_RANGES[variety];
          if (!stageRanges) return {};
          
          const progress = {};
          const stages = ['Germination', 'Tillering', 'Grand Growth', 'Maturity'];
          
          // Determine if crop is in Maturity stage or beyond
          const maturityRange = stageRanges.Maturity;
          const isInMaturityOrBeyond = maturityRange && DAP >= maturityRange.min;
          
          for (const stageName of stages) {
            const range = stageRanges[stageName];
            if (!range) {
              progress[stageName] = 0;
              continue;
            }
            
            // Maturity Rule: If crop is in Maturity or beyond, all previous stages = 100%
            if (isInMaturityOrBeyond && stageName !== 'Maturity') {
              progress[stageName] = 100;
            }
            // For Maturity stage itself, calculate normally
            else if (stageName === 'Maturity') {
              // If DAP is beyond maturity end ‚Üí Maturity = 100%
              if (DAP >= range.max) {
                progress[stageName] = 100;
              }
              // If DAP has not yet reached maturity ‚Üí Maturity = 0%
              else if (DAP < range.min) {
                progress[stageName] = 0;
              }
              // Calculate percentage: ((DAP ‚Äì Stage Start DAP) / (Stage End DAP ‚Äì Stage Start DAP)) √ó 100
              else {
                const stageDuration = range.max - range.min;
                const daysIntoStage = DAP - range.min;
                const percentage = Math.round((daysIntoStage / stageDuration) * 100);
                // Clamp between 0% and 100%
                progress[stageName] = Math.max(0, Math.min(100, percentage));
              }
            }
            // For non-maturity stages (only if not in maturity yet)
            else {
              // If DAP is beyond a stage's end ‚Üí stage = 100%
              if (DAP >= range.max) {
                progress[stageName] = 100;
              }
              // If DAP has not yet reached a stage ‚Üí stage = 0%
              else if (DAP < range.min) {
                progress[stageName] = 0;
              }
              // Calculate percentage: ((DAP ‚Äì Stage Start DAP) / (Stage End DAP ‚Äì Stage Start DAP)) √ó 100
              else {
                const stageDuration = range.max - range.min;
                const daysIntoStage = DAP - range.min;
                const percentage = Math.round((daysIntoStage / stageDuration) * 100);
                // Clamp between 0% and 100%
                progress[stageName] = Math.max(0, Math.min(100, percentage));
              }
            }
          }
          
          return progress;
        }

        // Show warnings for delays and overdue harvests
        function showWarnings(growthData) {
          const warningsContainer = document.createElement('div');
          warningsContainer.className = 'mt-4 space-y-2';
          warningsContainer.id = 'growthWarnings';
          const existingWarnings = document.getElementById('growthWarnings');
          if (existingWarnings) existingWarnings.remove();
          let hasWarnings = false;
          if (growthData.delayInfo && growthData.delayInfo.isDelayed) {
            hasWarnings = true;
            const delayWarning = document.createElement('div');
            delayWarning.className = 'px-4 py-3 rounded-lg bg-yellow-50 border border-yellow-200';
            delayWarning.innerHTML = `<div class="flex items-center gap-2"><i class="fas fa-exclamation-triangle text-yellow-600"></i><div class="text-sm"><p class="font-semibold text-yellow-800">Fertilization Delayed</p><p class="text-yellow-700">${growthData.delayInfo.delayType === 'basal' ? 'Basal' : growthData.delayInfo.delayType === 'main' ? 'Main' : 'Both'} fertilization is delayed by ${growthData.delayInfo.delayDays} days.</p></div></div>`;
            warningsContainer.appendChild(delayWarning);
          }
          if (growthData.overdueInfo && growthData.overdueInfo.isOverdue) {
            hasWarnings = true;
            const overdueWarning = document.createElement('div');
            overdueWarning.className = 'px-4 py-3 rounded-lg bg-red-50 border border-red-200';
            overdueWarning.innerHTML = `<div class="flex items-center gap-2"><i class="fas fa-exclamation-circle text-red-600"></i><div class="text-sm"><p class="font-semibold text-red-800">Harvest Overdue</p><p class="text-red-700">This field is ${growthData.overdueInfo.overdueDays} days overdue for harvest.</p></div></div>`;
            warningsContainer.appendChild(overdueWarning);
          }
          if (hasWarnings) {
            const growthCard = document.querySelector('.section-card');
            if (growthCard && growthCard.parentNode) {
              growthCard.parentNode.insertBefore(warningsContainer, growthCard.nextSibling);
            }
          }
        }

        // Show not planted state
        function showNotPlantedState() {
          // CRITICAL: Reset ALL growth-related UI elements when no planting exists
          // This ensures no growth data appears without planting
          const uiDays = document.getElementById('uiDays');
          const uiStage = document.getElementById('uiStage');
          const uiPlanted = document.getElementById('uiPlanted');
          const uiHarvest = document.getElementById('uiHarvest');
          const uiRemain = document.getElementById('uiRemain');
          const uiMonths = document.getElementById('uiMonths');
          const tlBar = document.getElementById('tlBar');
          const tlPct = document.getElementById('tlPct');
          const progressPercentage = document.getElementById('progressPercentage');
          const progressCurrent = document.getElementById('progressCurrent');
          const plantedDateDisplay = document.getElementById('plantedDateDisplay');
          
          // Reset all growth data displays
          if (uiDays) uiDays.textContent = '‚Äî';
          if (uiStage) uiStage.textContent = 'Not Planted';
          if (uiPlanted) uiPlanted.textContent = 'Not planted yet';
          if (uiHarvest) uiHarvest.textContent = '‚Äî';
          if (uiRemain) uiRemain.textContent = '‚Äî';
          if (uiMonths) uiMonths.textContent = '‚Äî';
          if (plantedDateDisplay) plantedDateDisplay.textContent = '‚Äî';
          
          // Reset progress bar
          if (tlBar) tlBar.style.width = '0%';
          if (tlPct) tlPct.textContent = '0';
          if (progressPercentage) progressPercentage.textContent = '0%';
          if (progressCurrent) progressCurrent.textContent = 'Not Planted';
          
          // Hide predicted harvest modal
          document.getElementById('predictedHarvestModal')?.classList.add('hidden');
          
          // Show info message
          const existing = document.getElementById('notPlantedInfo');
          if (existing) existing.remove();
          const infoDiv = document.createElement('div');
          infoDiv.className = 'mt-4 px-4 py-3 rounded-lg bg-blue-50 border border-blue-200';
          infoDiv.innerHTML = `<div class="flex items-center gap-2"><i class="fas fa-info-circle text-blue-600"></i><p class="text-sm text-blue-800">This field has not been planted yet. Growth tracking will begin once a planting task is completed.</p></div>`;
          infoDiv.id = 'notPlantedInfo';
          const growthCard = document.querySelector('.section-card');
          if (growthCard && growthCard.parentNode) {
            growthCard.parentNode.insertBefore(infoDiv, growthCard.nextSibling);
          }
        }

        // Show no fields message
        function showNoFieldsMessage() {
          const messageDiv = document.createElement('div');
          messageDiv.className = 'mt-6 px-4 py-8 rounded-lg bg-gray-50 border border-gray-200 text-center';
          messageDiv.innerHTML = `<i class="fas fa-map-marker-alt text-4xl text-gray-400 mb-3"></i><p class="text-gray-600 font-medium">No reviewed fields found</p><p class="text-sm text-gray-500 mt-2">Please register a field and wait for SRA approval.</p><a href="Register-field.html" class="mt-4 inline-block px-4 py-2 bg-[var(--cane-700)] text-white rounded-lg hover:bg-[var(--cane-800)] transition">Register a Field</a>`;
          const mainSection = document.querySelector('main section');
          if (mainSection) mainSection.appendChild(messageDiv);
        }

        // Show error message
        function showError(message) {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'fixed bottom-4 right-4 bg-red-600 text-white px-4 py-3 rounded-lg shadow-lg z-50';
          errorDiv.innerHTML = `<i class="fas fa-exclamation-circle mr-2"></i>${message}`;
          document.body.appendChild(errorDiv);
          setTimeout(() => errorDiv.remove(), 4000);
        }

        // ‚úÖ Display historical planting & harvest data
        async function displayHistoricalData(fieldId) {
          try {
            const selectedField = userFields.find(f => f.id === fieldId);
            if (!selectedField) return;

            const growthHistory = selectedField.growthHistory || {};
            const plantingHistory = selectedField.plantingHistory || {};

            // Combine both histories
            const allHistory = [];

            // Add ratoon cycles from growthHistory
            for (const [key, cycleData] of Object.entries(growthHistory)) {
              if (key.startsWith('cycle')) {
                allHistory.push({
                  ...cycleData,
                  type: 'ratoon',
                  cycleNumber: cycleData.cycle
                });
              }
            }

            // Add planting cycles from plantingHistory
            for (const [key, cycleData] of Object.entries(plantingHistory)) {
              if (key.startsWith('cycle')) {
                allHistory.push({
                  ...cycleData,
                  type: 'replant',
                  cycleNumber: cycleData.plantingCycle
                });
              }
            }

            // Sort by archived date (most recent first)
            allHistory.sort((a, b) => {
              const dateA = a.archivedAt?.toDate?.() || new Date(0);
              const dateB = b.archivedAt?.toDate?.() || new Date(0);
              return dateB - dateA;
            });

            // Show/hide historical section
            const historicalSection = document.getElementById('historicalDataSection');
            const historicalContent = document.getElementById('historicalDataContent');

            if (allHistory.length === 0) {
              historicalSection.style.display = 'none';
              return;
            }

            historicalSection.style.display = 'block';

            // Render historical data
            historicalContent.innerHTML = allHistory.map((cycle, index) => {
              const plantingDate = cycle.plantingDate?.toDate?.() || cycle.plantingDate;
              const harvestDate = cycle.actualHarvestDate?.toDate?.() || cycle.actualHarvestDate;
              const plantingStr = plantingDate ? plantingDate.toLocaleDateString() : '‚Äî';
              const harvestStr = harvestDate ? harvestDate.toLocaleDateString() : 'Not harvested';
              const dap = cycle.finalDAP || '‚Äî';
              const yield_ = cycle.actualYield ? `${cycle.actualYield} tons` : '‚Äî';
              const variety = cycle.variety || '‚Äî';
              const ratoonNum = cycle.ratoonNumber || 0;

              const typeLabel = cycle.type === 'ratoon' ? `Ratoon Cycle ${ratoonNum}` : `Planting Cycle ${cycle.cycleNumber}`;
              const typeIcon = cycle.type === 'ratoon' ? 'fa-redo' : 'fa-seedling';
              const typeColor = cycle.type === 'ratoon' ? 'text-blue-700' : 'text-green-700';
              const bgColor = cycle.type === 'ratoon' ? 'bg-blue-50' : 'bg-green-50';
              const borderColor = cycle.type === 'ratoon' ? 'border-blue-200' : 'border-green-200';

              return `
            <div class="border ${borderColor} ${bgColor} rounded-lg p-3 text-xs">
              <div class="flex items-center justify-between mb-2">
                <h4 class="font-semibold ${typeColor} flex items-center gap-1.5">
                  <i class="fas ${typeIcon}"></i>
                  ${typeLabel}
                </h4>
                <span class="text-[10px] text-gray-600">${cycle.archivedAt?.toDate?.()?.toLocaleDateString() || '‚Äî'}</span>
              </div>
              <div class="grid grid-cols-2 gap-2 text-gray-700">
                <div>
                  <span class="font-medium text-gray-600">Planted:</span>
                  <span class="block font-semibold">${plantingStr}</span>
                </div>
                <div>
                  <span class="font-medium text-gray-600">Harvested:</span>
                  <span class="block font-semibold">${harvestStr}</span>
                </div>
                <div>
                  <span class="font-medium text-gray-600">Final DAP:</span>
                  <span class="block font-semibold">${dap} days</span>
                </div>
                <div>
                  <span class="font-medium text-gray-600">Yield:</span>
                  <span class="block font-semibold">${yield_}</span>
                </div>
                <div class="col-span-2">
                  <span class="font-medium text-gray-600">Variety:</span>
                  <span class="block font-semibold">${variety}</span>
                </div>
              </div>
            </div>
          `;
            }).join('');

            // Setup toggle button
            const toggleBtn = document.getElementById('toggleHistoryBtn');
            let isCollapsed = false;

            toggleBtn.addEventListener('click', () => {
              isCollapsed = !isCollapsed;
              if (isCollapsed) {
                historicalContent.style.display = 'none';
                toggleBtn.innerHTML = '<i class="fas fa-chevron-down"></i> Expand';
              } else {
                historicalContent.style.display = 'block';
                toggleBtn.innerHTML = '<i class="fas fa-chevron-up"></i> Collapse';
              }
            });

          } catch (error) {
            console.error('Error displaying historical data:', error);
          }
        }

        // Load timeline nodes for a field with real-time updates
        async function loadTimelineNodes(fieldId) {
          // Unsubscribe from previous listener if exists
          if (recordsUnsubscribe) {
            recordsUnsubscribe();
            recordsUnsubscribe = null;
          }

          if (!fieldId) {
            console.warn('No fieldId provided to loadTimelineNodes');
            return;
          }

          // CRITICAL: Get planting date for DAP calculation, but still load records even if no planting
          // All reports must appear in timeline, but DAP mapping requires planting
          let plantingDate = null;
          try {
            const fieldRef = doc(db, 'fields', fieldId);
            const fieldSnap = await getDoc(fieldRef);
            if (fieldSnap.exists()) {
              const fieldData = fieldSnap.data();
              plantingDate = fieldData.plantingDate?.toDate?.() || fieldData.plantingDate;
            }
            // Also check window.latestGrowthData as fallback
            if (!plantingDate && window.latestGrowthData && window.latestGrowthData.plantingDate) {
              plantingDate = window.latestGrowthData.plantingDate;
            }
          } catch (error) {
            console.error('Error checking planting date:', error);
            // Continue anyway - will show records without DAP mapping
          }

          console.log(`üîç Setting up real-time listener for fieldId: ${fieldId}`);

          try {
            // Try ordering by recordDate first, fallback to createdAt
            let recordsQuery;
            try {
              recordsQuery = query(
                collection(db, 'records'),
                where('fieldId', '==', fieldId),
                orderBy('recordDate', 'desc')
              );
              console.log('‚úÖ Using recordDate ordering');
            } catch (e) {
              console.log('‚ö†Ô∏è Falling back to createdAt ordering:', e.message);
              // Fallback to createdAt if recordDate index doesn't exist
              recordsQuery = query(
                collection(db, 'records'),
                where('fieldId', '==', fieldId),
                orderBy('createdAt', 'desc')
              );
            }

            // Set up real-time listener with error handling
            recordsUnsubscribe = onSnapshot(
              recordsQuery,
              async (recordsSnapshot) => {
                console.log(`üìä Timeline updated: ${recordsSnapshot.docs.length} records found for field ${fieldId}`);
                const records = [];

                // Process all records
                for (const recordDoc of recordsSnapshot.docs) {
                  const recordData = recordDoc.data();
                  
                  // Load bought items subcollection
                  let boughtItems = [];
                  try {
                    const boughtItemsSnapshot = await getDocs(collection(db, 'records', recordDoc.id, 'bought_items'));
                    boughtItems = boughtItemsSnapshot.docs.map(doc => doc.data());
                  } catch (e) {
                    console.debug('No bought items subcollection:', e);
                  }
                  
                  // Load vehicle updates subcollection
                  let vehicleUpdates = null;
                  try {
                    const vehicleUpdatesSnapshot = await getDocs(collection(db, 'records', recordDoc.id, 'vehicle_updates'));
                    vehicleUpdates = vehicleUpdatesSnapshot.docs.length > 0 ? vehicleUpdatesSnapshot.docs[0].data() : null;
                  } catch (e) {
                    console.debug('No vehicle updates subcollection:', e);
                  }

                  records.push({
                    id: recordDoc.id,
                    ...recordData,
                    boughtItems,
                    vehicleUpdates
                  });
                }

                // Debug: Log record count and statuses
                console.log(`üìä Rendering ${records.length} records:`, records.map(r => ({ 
                  id: r.id, 
                  status: r.status, 
                  taskType: r.taskType,
                  fieldId: r.fieldId 
                })));

                // Render timeline with updated records (await since it's async)
                await renderTimelineNodes(records);
              },
              async (error) => {
                console.error('Error in timeline listener:', error);
                
                // If query fails due to permissions, try loading without orderBy
                if (error.code === 'permission-denied' || (error.message && error.message.includes('permission'))) {
                  console.log('‚ö†Ô∏è Permission error detected, trying query without orderBy...');
                  try {
                    // Try query without orderBy (less secure but might work)
                    const simpleQuery = query(
                      collection(db, 'records'),
                      where('fieldId', '==', fieldId)
                    );
                    
                    recordsUnsubscribe = onSnapshot(
                      simpleQuery,
                      async (snapshot) => {
                        const records = [];
                        for (const recordDoc of snapshot.docs) {
                          try {
                            const recordData = recordDoc.data();
                            
                            // Load bought items subcollection
                            let boughtItems = [];
                            try {
                              const boughtItemsSnapshot = await getDocs(collection(db, 'records', recordDoc.id, 'bought_items'));
                              boughtItems = boughtItemsSnapshot.docs.map(doc => doc.data());
                            } catch (e) {
                              console.debug('No bought items:', e);
                            }
                            
                            // Load vehicle updates subcollection
                            let vehicleUpdates = null;
                            try {
                              const vehicleUpdatesSnapshot = await getDocs(collection(db, 'records', recordDoc.id, 'vehicle_updates'));
                              vehicleUpdates = vehicleUpdatesSnapshot.docs.length > 0 ? vehicleUpdatesSnapshot.docs[0].data() : null;
                            } catch (e) {
                              console.debug('No vehicle updates:', e);
                            }
                            
                            records.push({
                              id: recordDoc.id,
                              ...recordData,
                              boughtItems,
                              vehicleUpdates
                            });
                          } catch (docError) {
                            console.warn('Error processing record:', docError);
                          }
                        }
                        
                        // Sort client-side by recordDate or createdAt
                        records.sort((a, b) => {
                          const dateA = a.recordDate?.toDate?.() || a.createdAt?.toDate?.() || new Date(0);
                          const dateB = b.recordDate?.toDate?.() || b.createdAt?.toDate?.() || new Date(0);
                          return dateB - dateA;
                        });
                        
                        console.log(`üìä Loaded ${records.length} records (without orderBy)`);
                        await renderTimelineNodes(records);
                      },
                      (fallbackError) => {
                        console.error('Fallback query also failed:', fallbackError);
                        const emptyState = document.getElementById('timelineEmptyState');
                        if (emptyState) emptyState.classList.remove('hidden');
                      }
                    );
                    return; // Exit early if fallback succeeds
                  } catch (fallbackError) {
                    console.error('Fallback query setup failed:', fallbackError);
                  }
                }
                
                // If query fails due to missing index, try fallback
                if (error.message && error.message.includes('index')) {
                  console.log('Trying fallback query with createdAt...');
                  try {
                    const fallbackQuery = query(
                      collection(db, 'records'),
                      where('fieldId', '==', fieldId),
                      orderBy('createdAt', 'desc')
                    );
                    
                    recordsUnsubscribe = onSnapshot(fallbackQuery, async (snapshot) => {
                      const records = [];
                      for (const recordDoc of snapshot.docs) {
                        const recordData = recordDoc.data();
                        records.push({
                          id: recordDoc.id,
                          ...recordData,
                          boughtItems: [],
                          vehicleUpdates: null
                        });
                      }
                      await renderTimelineNodes(records);
                    });
                  } catch (fallbackError) {
                    console.error('Fallback query also failed:', fallbackError);
                    const emptyState = document.getElementById('timelineEmptyState');
                    if (emptyState) emptyState.classList.remove('hidden');
                  }
                } else {
                  const emptyState = document.getElementById('timelineEmptyState');
                  if (emptyState) emptyState.classList.remove('hidden');
                }
              }
            );
          } catch (error) {
            console.error('Error setting up timeline listener:', error);
            const emptyState = document.getElementById('timelineEmptyState');
            if (emptyState) emptyState.classList.remove('hidden');
          }
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
          if (!text) return '';
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        // Render timeline nodes integrated into growth stages
        // CRITICAL: All submitted reports must appear, mapped to stages based on DAP
        async function renderTimelineNodes(records) {
          console.log(`üé® Rendering ${records.length} records into timeline`);
          const emptyState = document.getElementById('timelineEmptyState');
          
          if (records.length === 0) {
            console.log('No records found, showing empty state');
            if (emptyState) emptyState.classList.remove('hidden');
            // Clear all activity containers
            ['germination', 'tillering', 'grand', 'maturing', 'harvest'].forEach(stage => {
              const container = document.getElementById(`activities-${stage}`);
              if (container) {
                container.innerHTML = `
                  <div class="activity-node empty-state">
                    <p class="text-xs text-gray-500 italic">No activities recorded yet</p>
                  </div>
                `;
              }
            });
            return;
          }

          // Hide empty state if we have records
          if (emptyState) emptyState.classList.add('hidden');

          // Get planting date from multiple sources for accurate DAP calculation
          let plantingDate = null;
          
          // First, try window.latestGrowthData (most reliable)
          if (window.latestGrowthData && window.latestGrowthData.plantingDate) {
            plantingDate = window.latestGrowthData.plantingDate;
          } else {
            // Fallback: Try to get from field document
            try {
              const fieldId = records.length > 0 ? records[0].fieldId : null;
              if (fieldId) {
                const fieldRef = doc(db, 'fields', fieldId);
                const fieldSnap = await getDoc(fieldRef);
                if (fieldSnap.exists()) {
                  const fieldData = fieldSnap.data();
                  plantingDate = fieldData.plantingDate?.toDate?.() || fieldData.plantingDate;
                }
              }
              
              // If still no planting date, try to find planting record
              if (!plantingDate) {
                const plantingRecord = records.find(r => 
                  r.taskType === 'Planting Operation' || 
                  r.operation === 'Planting' ||
                  (r.taskType && r.taskType.toLowerCase().includes('planting'))
                );
                if (plantingRecord) {
                  plantingDate = plantingRecord.recordDate?.toDate?.() || 
                                 plantingRecord.createdAt?.toDate?.() || 
                                 plantingRecord.startDate;
                }
              }
            } catch (e) {
              console.debug('Could not get planting date:', e);
            }
          }

          // Helper function to calculate DAP using Current Date - Planting Date
          // This ensures all records (including Germination stage) display correct DAP
          const calculateDAPForRecord = () => {
            if (!plantingDate) return null;
            const planting = plantingDate instanceof Date ? plantingDate : new Date(plantingDate);
            // Use current date for DAP calculation: Current Date - Planting Date
            const currentDate = new Date();
            const diffTime = currentDate - planting;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            return Math.max(0, diffDays);
          };

          // Helper function to map DAP to growth stage (fallback for old records without status)
          // CRITICAL: All records must be mapped to a stage, even if before planting
          const getStageFromDAP = (dap) => {
            // If no planting date exists, all records go to Germination stage
            if (dap === null || !plantingDate) return 'Germination';
            // Map based on DAP ranges
            if (dap < 45) return 'Germination';
            if (dap < 100) return 'Tillering';
            if (dap < 240) return 'Grand Growth';
            if (dap < 300) return 'Maturing / Ripening';
            return 'Harvest';
          };

          // Helper function to normalize stage name from record status
          const normalizeStageName = (status) => {
            if (!status) return null;
            const normalized = status.trim();
            // Map common variations to standard stage names
            if (normalized === 'Germination') return 'Germination';
            if (normalized === 'Tillering') return 'Tillering';
            if (normalized === 'Grand Growth') return 'Grand Growth';
            if (normalized === 'Maturing / Ripening' || normalized === 'Maturing/Ripening' || normalized.includes('Maturing') || normalized.includes('Ripening')) return 'Maturing / Ripening';
            if (normalized === 'Harvest') return 'Harvest';
            return null;
          };

          // Group ALL records by growth stage based on status field (or DAP fallback)
          const groupedByStage = {
            'Germination': [],
            'Tillering': [],
            'Grand Growth': [],
            'Maturing / Ripening': [],
            'Harvest': []
          };

          // Process ALL records and map them to stages
          records.forEach(record => {
            // Get record date (prefer recordDate, fallback to createdAt or startDate)
            const recordDate = record.recordDate?.toDate?.() || 
                              record.createdAt?.toDate?.() || 
                              record.startDate || 
                              new Date();
            
            // Calculate DAP for this record using Current Date - Planting Date
            const dap = calculateDAPForRecord();
            
            // Determine stage: Use status field if available, otherwise fall back to DAP-based mapping
            let stage = null;
            
            // First, try to use the status field from the record
            if (record.status) {
              stage = normalizeStageName(record.status);
            }
            
            // If status field is not available or doesn't match known stages, fall back to DAP-based mapping
            if (!stage) {
              stage = getStageFromDAP(dap);
            }
            
            // Ensure stage is valid, default to Germination if not
            if (!groupedByStage.hasOwnProperty(stage)) {
              console.warn(`Unknown stage "${stage}" for record ${record.id}, defaulting to Germination`);
              stage = 'Germination';
            }
            
            // Add record to appropriate stage with DAP info
            groupedByStage[stage].push({
              ...record,
              _dap: dap,
              _recordDate: recordDate
            });
          });

          // Map stage names to container IDs
          const stageToContainer = {
            'Germination': 'germination',
            'Tillering': 'tillering',
            'Grand Growth': 'grand',
            'Maturing / Ripening': 'maturing',
            'Harvest': 'harvest'
          };

          // Render activities into each stage container
          Object.entries(groupedByStage).forEach(([stage, stageRecords]) => {
            const containerId = stageToContainer[stage];
            const container = document.getElementById(`activities-${containerId}`);
            
            if (!container) {
              console.warn(`Container not found for stage: ${stage} (${containerId})`);
              return;
            }

            console.log(`üìù Rendering ${stageRecords.length} records for ${stage} stage`);

            if (stageRecords.length === 0) {
              container.innerHTML = `
                <div class="activity-node empty-state">
                  <p class="text-xs text-gray-500 italic">No activities recorded yet</p>
                </div>
              `;
              return;
            }

            // CRITICAL: Sort records chronologically (earliest first) within each stage
            // This ensures the first submitted report appears at the top
            stageRecords.sort((a, b) => {
              const dateA = a._recordDate || a.recordDate?.toDate?.() || a.createdAt?.toDate?.() || new Date(0);
              const dateB = b._recordDate || b.recordDate?.toDate?.() || b.createdAt?.toDate?.() || new Date(0);
              return dateA - dateB; // Oldest first (chronological order)
            });

            let html = '';
            stageRecords.forEach(record => {
              // Use the stored record date from processing
              const recordDate = record._recordDate || record.recordDate?.toDate?.() || record.createdAt?.toDate?.() || new Date();
              const dateStr = recordDate.toLocaleDateString();
              // Get task type from various possible fields
              const taskType = record.taskType || record.operation || record.taskName || 'Activity Record';
              const dap = record._dap;
              
              // Get brief summary from data
              let summary = '';
              if (record.data) {
                const notes = record.data.notes || record.data.remarks || '';
                summary = notes.length > 40 ? notes.substring(0, 40) + '...' : notes;
              }

              // Escape HTML to prevent XSS
              const safeTaskType = escapeHtml(taskType);
              const safeDateStr = escapeHtml(dateStr);
              const safeSummary = escapeHtml(summary);
              
              // Show DAP if available and planting exists
              const dapDisplay = (dap !== null && plantingDate) ? ` ‚Ä¢ ${dap} DAP` : '';

              html += `
                <div class="activity-node" 
                     data-record-id="${record.id}"
                     onclick="window.openRecordModal('${record.id}')"
                     role="button"
                     tabindex="0"
                     onkeypress="if(event.key==='Enter') window.openRecordModal('${record.id}')"
                     title="Click to preview record details">
                  <div class="flex items-start justify-between gap-2">
                    <div class="flex-1 min-w-0">
                      <div class="flex items-center gap-2 mb-1">
                        <p class="font-medium text-sm text-[var(--cane-800)] truncate flex-1">${safeTaskType}</p>
                        <span class="text-xs px-2 py-0.5 bg-[var(--cane-100)] text-[var(--cane-700)] rounded font-medium whitespace-nowrap">Preview</span>
                      </div>
                      <div class="flex items-center gap-2 mt-1">
                        <i class="fas fa-calendar text-xs text-gray-400"></i>
                        <p class="text-xs text-gray-600">${safeDateStr}${dapDisplay}</p>
                      </div>
                      ${safeSummary ? `<p class="text-xs text-gray-500 mt-1 truncate">${safeSummary}</p>` : ''}
                    </div>
                    <i class="fas fa-chevron-right text-gray-400 text-xs mt-1 flex-shrink-0"></i>
                  </div>
                </div>
              `;
            });

            container.innerHTML = html;
          });
        }

        // Open record detail modal
        async function openRecordModal(recordId) {
          try {
            const { getDoc, doc, collection, getDocs } = await import('https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js');
            
            const recordRef = doc(db, 'records', recordId);
            const recordSnap = await getDoc(recordRef);
            
            if (!recordSnap.exists()) {
              showError('Record not found');
              return;
            }

            const recordData = recordSnap.data();
            
            // Load bought items
            const boughtItemsSnapshot = await getDocs(collection(db, 'records', recordId, 'bought_items'));
            const boughtItems = boughtItemsSnapshot.docs.map(doc => doc.data());
            
            // Load vehicle updates
            const vehicleUpdatesSnapshot = await getDocs(collection(db, 'records', recordId, 'vehicle_updates'));
            const vehicleUpdates = vehicleUpdatesSnapshot.docs.length > 0 ? vehicleUpdatesSnapshot.docs[0].data() : null;

            // Get field name
            const fieldRef = doc(db, 'fields', recordData.fieldId);
            const fieldSnap = await getDoc(fieldRef);
            const fieldName = fieldSnap.exists() ? (fieldSnap.data().field_name || 'Unknown Field') : 'Unknown Field';

            // Render modal content
            renderRecordModal({
              ...recordData,
              id: recordId,
              fieldName,
              boughtItems,
              vehicleUpdates
            });

            // Show modal
            const modal = document.getElementById('recordDetailModal');
            if (modal) {
              modal.classList.remove('hidden');
            } else {
              console.error('Record detail modal not found');
            }
          } catch (error) {
            console.error('Error opening record modal:', error);
            showError('Failed to load record details');
          }
        }

        // Helper function to format status badge
        function getStatusBadge(status) {
          const statusLower = (status || '').toLowerCase().replace(/\s+/g, '-');
          const statusClass = statusLower.includes('germination') ? 'germination' :
                             statusLower.includes('tillering') ? 'tillering' :
                             statusLower.includes('grand') ? 'grand-growth' :
                             statusLower.includes('maturing') || statusLower.includes('ripening') ? 'maturing' :
                             statusLower.includes('harvest') ? 'harvest' : 'germination';
          return `<span class="status-badge ${statusClass}">${escapeHtml(status || 'N/A')}</span>`;
        }

        // Helper function to format date
        function formatDate(date) {
          if (!date) return 'N/A';
          const d = date.toDate ? date.toDate() : new Date(date);
          return d.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          });
        }

        // Helper function to format currency
        function formatCurrency(amount) {
          if (!amount && amount !== 0) return '‚Ç±0.00';
          return `‚Ç±${parseFloat(amount).toFixed(2)}`;
        }

        // Render record modal content
        function renderRecordModal(record) {
          const content = document.getElementById('recordDetailContent');
          if (!content) {
            console.error('Record detail content container not found');
            return;
          }
          
          const recordDate = record.recordDate?.toDate?.() || record.createdAt?.toDate?.() || new Date();
          const statusBadge = getStatusBadge(record.status);
          
          let html = `
            <div class="space-y-6 animate-slideUp">
              <!-- Basic Information Card -->
              <div class="record-info-card">
                <h4 class="record-section-title">
                  <i class="fas fa-info-circle text-[var(--cane-600)]"></i>
                  Basic Information
                </h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <div class="record-info-label">
                      <i class="fas fa-map-marker-alt text-[var(--cane-600)]"></i>
                      Field Name
                    </div>
                    <p class="record-info-value">${escapeHtml(record.fieldName || 'N/A')}</p>
                  </div>
                  <div>
                    <div class="record-info-label">
                      <i class="fas fa-calendar-alt text-[var(--cane-600)]"></i>
                      Date Submitted
                    </div>
                    <p class="record-info-value">${formatDate(recordDate)}</p>
                  </div>
                  <div>
                    <div class="record-info-label">
                      <i class="fas fa-tag text-[var(--cane-600)]"></i>
                      Growth Stage / Status
                    </div>
                    <div class="mt-1">${statusBadge}</div>
                  </div>
                  <div>
                    <div class="record-info-label">
                      <i class="fas fa-cogs text-[var(--cane-600)]"></i>
                      Field Operation
                    </div>
                    <p class="record-info-value">${escapeHtml(record.operation || 'N/A')}</p>
                  </div>
                  <div class="md:col-span-2">
                    <div class="record-info-label">
                      <i class="fas fa-tasks text-[var(--cane-600)]"></i>
                      Task Type
                    </div>
                    <p class="record-info-value text-base">${escapeHtml(record.taskType || 'N/A')}</p>
                  </div>
                </div>
              </div>

              <!-- Task Details Card -->
              <div class="record-info-card">
                <h4 class="record-section-title">
                  <i class="fas fa-clipboard-list text-[var(--cane-600)]"></i>
                  Task Details
                </h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          `;

          // Render task-specific data fields
          if (record.data && Object.keys(record.data).length > 0) {
            Object.entries(record.data).forEach(([key, value]) => {
              if (value !== null && value !== undefined && value !== '') {
                const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).trim();
                const iconMap = {
                  'date': 'fa-calendar',
                  'Date': 'fa-calendar',
                  'workers': 'fa-users',
                  'Workers': 'fa-users',
                  'operators': 'fa-user-tie',
                  'Operators': 'fa-user-tie',
                  'equipment': 'fa-tractor',
                  'Equipment': 'fa-tractor',
                  'notes': 'fa-sticky-note',
                  'Notes': 'fa-sticky-note',
                  'remarks': 'fa-comment',
                  'Remarks': 'fa-comment',
                  'variety': 'fa-seedling',
                  'Variety': 'fa-seedling',
                  'quantity': 'fa-hashtag',
                  'Quantity': 'fa-hashtag',
                  'cost': 'fa-peso-sign',
                  'Cost': 'fa-peso-sign'
                };
                
                const iconKey = Object.keys(iconMap).find(k => label.toLowerCase().includes(k.toLowerCase()));
                const icon = iconKey ? iconMap[iconKey] : 'fa-circle';
                
                // Format value based on type
                let formattedValue = value;
                if (typeof value === 'number' && label.toLowerCase().includes('cost')) {
                  formattedValue = formatCurrency(value);
                } else if (value instanceof Date || (typeof value === 'object' && value.toDate)) {
                  formattedValue = formatDate(value);
                } else {
                  formattedValue = escapeHtml(String(value));
                }
                
                html += `
                  <div>
                    <div class="record-info-label">
                      <i class="fas ${icon} text-[var(--cane-600)]"></i>
                      ${escapeHtml(label)}
                    </div>
                    <p class="record-info-value">${formattedValue}</p>
                  </div>
                `;
              }
            });
          } else {
            html += `
              <div class="md:col-span-2 text-center py-4 text-gray-500">
                <i class="fas fa-inbox text-3xl mb-2 opacity-50"></i>
                <p class="text-sm">No task details available</p>
              </div>
            `;
          }

          html += `
                </div>
              </div>
          `;

          // Bought Items section
          if (record.boughtItems && record.boughtItems.length > 0) {
            html += `
              <div class="record-info-card">
                <h4 class="record-section-title">
                  <i class="fas fa-shopping-cart text-[var(--cane-600)]"></i>
                  Bought Items (${record.boughtItems.length})
                </h4>
                <div class="space-y-3">
            `;
            
            record.boughtItems.forEach((item, index) => {
              html += `
                <div class="bg-gradient-to-r from-[var(--cane-50)] to-white rounded-lg p-4 border border-[var(--cane-200)] hover:shadow-md transition-shadow">
                  <div class="flex items-start justify-between mb-3">
                    <div class="flex items-center gap-2">
                      <div class="w-8 h-8 rounded-lg bg-[var(--cane-600)] flex items-center justify-center text-white font-bold text-sm">
                        ${index + 1}
                      </div>
                      <div>
                        <p class="font-bold text-base text-gray-900">${escapeHtml(item.itemName || 'Unnamed Item')}</p>
                        <p class="text-xs text-gray-500 mt-0.5">${escapeHtml(item.supplier || 'No supplier')}</p>
                      </div>
                    </div>
                    <div class="text-right">
                      <p class="text-lg font-bold text-[var(--cane-700)]">${formatCurrency(item.total || 0)}</p>
                      <p class="text-xs text-gray-500">Total</p>
                    </div>
                  </div>
                  <div class="grid grid-cols-2 md:grid-cols-4 gap-3 pt-3 border-t border-gray-200">
                    <div>
                      <p class="text-xs font-semibold text-gray-600 mb-1">Quantity</p>
                      <p class="text-sm font-semibold text-gray-900">${item.quantity || 0} ${escapeHtml(item.unit || '')}</p>
                    </div>
                    <div>
                      <p class="text-xs font-semibold text-gray-600 mb-1">Unit Price</p>
                      <p class="text-sm font-semibold text-gray-900">${formatCurrency(item.price || 0)}</p>
                    </div>
                    <div class="md:col-span-2">
                      ${item.notes ? `
                        <p class="text-xs font-semibold text-gray-600 mb-1">Notes</p>
                        <p class="text-sm text-gray-700">${escapeHtml(item.notes)}</p>
                      ` : ''}
                    </div>
                  </div>
                </div>
              `;
            });
            
            // Calculate total
            const totalAmount = record.boughtItems.reduce((sum, item) => sum + (parseFloat(item.total) || 0), 0);
            html += `
                  <div class="mt-4 pt-4 border-t-2 border-[var(--cane-300)]">
                    <div class="flex justify-between items-center">
                      <span class="text-base font-bold text-gray-700">Total Amount:</span>
                      <span class="text-xl font-bold text-[var(--cane-700)]">${formatCurrency(totalAmount)}</span>
                    </div>
                  </div>
                </div>
              </div>
            `;
          }

          // Vehicle Updates section
          if (record.vehicleUpdates) {
            const vu = record.vehicleUpdates;
            html += `
              <div class="record-info-card">
                <h4 class="record-section-title">
                  <i class="fas fa-truck text-[var(--cane-600)]"></i>
                  Vehicle / Transport Updates
                </h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <div class="record-info-label">
                      <i class="fas fa-truck-pickup text-[var(--cane-600)]"></i>
                      Vehicle Type
                    </div>
                    <p class="record-info-value">${escapeHtml(vu.vehicleType || 'N/A')}</p>
                  </div>
                  <div>
                    <div class="record-info-label">
                      <i class="fas fa-boxes text-[var(--cane-600)]"></i>
                      Trips / Boxes
                    </div>
                    <p class="record-info-value">${vu.tripsBoxes || 0}</p>
                  </div>
                  <div>
                    <div class="record-info-label">
                      <i class="fas fa-gas-pump text-[var(--cane-600)]"></i>
                      Fuel Cost
                    </div>
                    <p class="record-info-value">${formatCurrency(vu.fuelCost || 0)}</p>
                  </div>
                  <div>
                    <div class="record-info-label">
                      <i class="fas fa-user-hard-hat text-[var(--cane-600)]"></i>
                      Labor Cost
                    </div>
                    <p class="record-info-value">${formatCurrency(vu.laborCost || 0)}</p>
                  </div>
                  <div class="md:col-span-2">
                    <div class="bg-gradient-to-r from-[var(--cane-50)] to-white rounded-lg p-4 border-2 border-[var(--cane-300)]">
                      <div class="flex justify-between items-center">
                        <div class="record-info-label mb-0">
                          <i class="fas fa-calculator text-[var(--cane-600)]"></i>
                          Total Cost
                        </div>
                        <p class="text-2xl font-bold text-[var(--cane-700)]">${formatCurrency(vu.totalCost || 0)}</p>
                      </div>
                    </div>
                  </div>
                  ${vu.route ? `
                    <div class="md:col-span-2">
                      <div class="record-info-label">
                        <i class="fas fa-route text-[var(--cane-600)]"></i>
                        Route / Field
                      </div>
                      <p class="record-info-value">${escapeHtml(vu.route)}</p>
                    </div>
                  ` : ''}
                </div>
              </div>
            `;
          }

          html += `
            </div>
          `;

          content.innerHTML = html;
        }

        // Close record modal (wait for DOM to be ready)
        const closeRecordModalBtn = document.getElementById('closeRecordModal');
        const recordDetailModalEl = document.getElementById('recordDetailModal');
        
        if (closeRecordModalBtn) {
          closeRecordModalBtn.addEventListener('click', () => {
            if (recordDetailModalEl) recordDetailModalEl.classList.add('hidden');
          });
        }

        // Close modal on backdrop click
        if (recordDetailModalEl) {
          recordDetailModalEl.addEventListener('click', (e) => {
            if (e.target.id === 'recordDetailModal') {
              recordDetailModalEl.classList.add('hidden');
            }
          });
        }

        // Check and display predicted harvest
        async function checkPredictedHarvest(fieldId) {
          try {
            const fieldRef = doc(db, 'fields', fieldId);
            const fieldSnap = await getDoc(fieldRef);
            
            if (!fieldSnap.exists()) return;
            
            const fieldData = fieldSnap.data();
            const plantingDate = fieldData.plantingDate?.toDate?.() || fieldData.plantingDate;
            
            // CRITICAL: Only show predicted harvest if planting date exists
            // Planting record is the single source of truth
            if (!plantingDate) {
              document.getElementById('predictedHarvestModal')?.classList.add('hidden');
              return;
            }
            
            const expectedHarvestDate = fieldData.expectedHarvestDate?.toDate?.() || fieldData.expectedHarvestDate;
            const variety = fieldData.sugarcane_variety || fieldData.variety;
            const currentStatus = fieldData.currentGrowthStage || fieldData.status;
            
            // Only show if not yet harvested and has expected harvest date
            if (expectedHarvestDate && currentStatus !== 'Harvested' && currentStatus !== 'harvested') {
              const modal = document.getElementById('predictedHarvestModal');
              const content = document.getElementById('predictedHarvestContent');
              
              const harvestDateStr = expectedHarvestDate instanceof Date 
                ? expectedHarvestDate.toLocaleDateString() 
                : new Date(expectedHarvestDate).toLocaleDateString();
              
              content.innerHTML = `
                <div class="space-y-2">
                  <div><span class="font-medium">Variety:</span> ${variety || 'Not specified'}</div>
                  <div><span class="font-medium">Predicted Harvest Date:</span> ${harvestDateStr}</div>
                  <div class="text-xs text-gray-600 mt-2">
                    <i class="fas fa-info-circle"></i> Based on planting date and variety growth cycle
                  </div>
                </div>
              `;
              
              modal.classList.remove('hidden');
            } else {
              document.getElementById('predictedHarvestModal').classList.add('hidden');
            }
          } catch (error) {
            console.error('Error checking predicted harvest:', error);
          }
        }

        // Close predicted harvest modal
        const closePredictedHarvestBtn = document.getElementById('closePredictedHarvest');
        if (closePredictedHarvestBtn) {
          closePredictedHarvestBtn.addEventListener('click', () => {
            const modal = document.getElementById('predictedHarvestModal');
            if (modal) modal.classList.add('hidden');
          });
        }

        // Make openRecordModal available globally
        window.openRecordModal = openRecordModal;

        // Cleanup listener on page unload
        window.addEventListener('beforeunload', () => {
          if (recordsUnsubscribe) {
            recordsUnsubscribe();
            recordsUnsubscribe = null;
          }
        });
      </script>

      <script>
        // Wait for html2pdf to be available
        function waitForHtml2pdf() {
          return new Promise((resolve) => {
            // Check both window.html2pdf and global html2pdf
            const checkHtml2pdf = () => {
              return typeof window.html2pdf !== 'undefined' || typeof html2pdf !== 'undefined';
            };
            
            if (checkHtml2pdf()) {
              resolve();
            } else {
              const checkInterval = setInterval(() => {
                if (checkHtml2pdf()) {
                  clearInterval(checkInterval);
                  resolve();
                }
              }, 100);
              // Timeout after 10 seconds
              setTimeout(() => {
                clearInterval(checkInterval);
                resolve();
              }, 10000);
            }
          });
        }

        // Initialize buttons when DOM is ready
        function initializeButtons() {
          // Add timestamp on print
          window.onbeforeprint = () => {
            const stamp = document.getElementById("generatedStamp");
            if (stamp) {
              stamp.textContent = new Date().toLocaleString();
            }
          };

          // PRINT BUTTON
          const printBtn = document.getElementById("btnPrint");
          if (printBtn) {
            printBtn.addEventListener("click", async () => {
              const originalContent = printBtn.innerHTML;
              printBtn.disabled = true;
              printBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Loading...';
              
              try {
                // Get current selected field ID from global reference or try to get from select element
                const fieldId = window.selectedFieldIdRef?.value || 
                               (document.getElementById('gtField')?.value) || 
                               null;
                
                // Ensure data is loaded before printing
                if (fieldId && typeof window.displayFieldGrowthData === 'function') {
                  try {
                    // Refresh data to ensure it's current
                    await window.displayFieldGrowthData(fieldId);
                    // Wait for timeline nodes to load
                    if (typeof window.loadTimelineNodes === 'function') {
                      await window.loadTimelineNodes(fieldId);
                    }
                    // Small delay to ensure DOM updates are complete
                    await new Promise(resolve => setTimeout(resolve, 300));
                  } catch (error) {
                    console.warn('Error refreshing data for print:', error);
                    // Continue with print even if refresh fails
                  }
                }
                
                const stamp = document.getElementById("generatedStamp");
                if (stamp) {
                  stamp.textContent = new Date().toLocaleString();
                }
                
                // Restore button state
                printBtn.disabled = false;
                printBtn.innerHTML = originalContent;
                
                // Small delay to ensure all content is rendered before print dialog
                setTimeout(() => {
                  window.print();
                }, 200);
              } catch (error) {
                console.error('Error preparing print:', error);
                // Always re-enable button on error
                printBtn.disabled = false;
                printBtn.innerHTML = originalContent;
                alert('Failed to prepare print. Please try again.');
              }
            });
          }

          // PDF BUTTON (captures the whole UI)
          const pdfBtn = document.getElementById("btnDownloadPDF");
          if (pdfBtn) {
            pdfBtn.addEventListener("click", async () => {
              const btn = document.getElementById("btnDownloadPDF");
              const printBtn = document.getElementById("btnPrint");
              const originalContent = btn.innerHTML;
              
              // Disable both buttons to prevent multiple clicks
              btn.disabled = true;
              if (printBtn) printBtn.disabled = true;
              btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Generating...';

              try {
                // Get current selected field ID from global reference or try to get from select element
                const fieldId = window.selectedFieldIdRef?.value || 
                               (document.getElementById('gtField')?.value) || 
                               null;
                
                // Ensure data is loaded before generating PDF
                if (fieldId && typeof window.displayFieldGrowthData === 'function') {
                  try {
                    await window.displayFieldGrowthData(fieldId);
                    // Wait for timeline nodes to load
                    if (typeof window.loadTimelineNodes === 'function') {
                      await window.loadTimelineNodes(fieldId);
                    }
                    // Small delay to ensure DOM updates are complete
                    await new Promise(resolve => setTimeout(resolve, 300));
                  } catch (error) {
                    console.warn('Error refreshing data for PDF:', error);
                    // Continue with PDF generation even if refresh fails
                  }
                }
                
                // Ensure html2pdf is loaded
                await waitForHtml2pdf();
                
                // Get html2pdf function (check both window.html2pdf and global html2pdf)
                const html2pdfFn = window.html2pdf || html2pdf;
                
                if (typeof html2pdfFn === 'undefined') {
                  throw new Error('html2pdf library failed to load. Please refresh the page.');
                }

                const stamp = document.getElementById("generatedStamp");
                if (stamp) {
                  stamp.textContent = new Date().toLocaleString();
                }

                const content = document.getElementById("captureArea");
                if (!content) {
                  throw new Error('Content area not found');
                }
                
                const filename = `CaneMap_Growth_Report_${Date.now()}.pdf`;
                
                // Enhanced html2canvas options to handle gradients and complex CSS
                const opt = {
                  margin: [10, 10, 10, 10],
                  filename: filename,
                  html2canvas: { 
                    scale: 2,
                    useCORS: true,
                    allowTaint: false, // Changed to false to avoid taint issues
                    backgroundColor: '#ffffff',
                    logging: false,
                    windowWidth: content.scrollWidth,
                    windowHeight: content.scrollHeight,
                    removeContainer: false,
                    imageTimeout: 15000,
                    timeout: 30000, // 30 second timeout for canvas generation
                    onclone: (clonedDoc) => {
                      // Fix gradients and complex CSS that cause issues in html2canvas
                      try {
                        const clonedWindow = clonedDoc.defaultView || clonedDoc.parentWindow;
                        if (clonedWindow) {
                          const style = clonedDoc.createElement('style');
                          style.textContent = `
                            * {
                              background-image: none !important;
                              -webkit-background-clip: unset !important;
                              background-clip: unset !important;
                            }
                            .bg-gradient-to-br,
                            .bg-gradient-to-r,
                            .bg-gradient-to-b,
                            body.bg-gradient-to-br {
                              background: #f0f7e9 !important;
                              background-image: none !important;
                            }
                            .progress-bar-fill,
                            .progress-bar-fill::after {
                              background: #3a7a0f !important;
                              background-image: none !important;
                            }
                            .progress-bar-track {
                              background: #e5e7eb !important;
                              background-image: none !important;
                            }
                            [class*="gradient"],
                            [style*="gradient"] {
                              background-image: none !important;
                            }
                          `;
                          clonedDoc.head.appendChild(style);
                        }
                        
                        // Also remove gradient styles from inline styles
                        const allElements = clonedDoc.querySelectorAll('*');
                        allElements.forEach(el => {
                          const style = el.style;
                          if (style.backgroundImage && style.backgroundImage.includes('gradient')) {
                            style.backgroundImage = 'none';
                          }
                          if (style.background && style.background.includes('gradient')) {
                            const bgColor = window.getComputedStyle(el).backgroundColor || '#f0f7e9';
                            style.background = bgColor;
                            style.backgroundImage = 'none';
                          }
                        });
                      } catch (cloneError) {
                        console.warn('Error in onclone callback:', cloneError);
                        // Continue even if onclone fails
                      }
                    }
                  },
                  jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
                };

                // Generate PDF - use Android-compatible method if in app, otherwise use standard
                try {
                  const { isAndroidApp, downloadFile } = await import('../../backend/Common/android-download.js');

                  if (isAndroidApp && isAndroidApp()) {
                    // For Android: Generate blob and use download utility
                    const pdfBlob = await new Promise((resolve, reject) => {
                      try {
                        html2pdfFn()
                          .set(opt)
                          .from(content)
                          .outputPdf('blob')
                          .then(resolve)
                          .catch(reject);
                      } catch (e) {
                        reject(e);
                      }
                    });
                    
                    if (!pdfBlob || pdfBlob.size === 0) {
                      throw new Error('Generated PDF is empty');
                    }
                    
                    await downloadFile(pdfBlob, filename);
                    // Small delay to ensure download starts before hiding animation
                    await new Promise(resolve => setTimeout(resolve, 500));
                  } else {
                    // For browser: Use standard save method
                    await html2pdfFn()
                      .set(opt)
                      .from(content)
                      .save();
                    // Small delay to ensure download starts before hiding animation
                    await new Promise(resolve => setTimeout(resolve, 300));
                  }
                } catch (importError) {
                  // Fallback if android-download module is not available
                  console.warn('Android download module not available, using standard method:', importError);
                  await html2pdfFn()
                    .set(opt)
                    .from(content)
                    .save();
                  await new Promise(resolve => setTimeout(resolve, 300));
                }
              } catch (error) {
                console.error('Error generating PDF:', error);
                alert('Failed to generate PDF: ' + (error.message || 'Please try again.'));
              } finally {
                // Always re-enable buttons, even on error
                btn.disabled = false;
                if (printBtn) printBtn.disabled = false;
                btn.innerHTML = originalContent;
              }
            });
          }
        }

        // Initialize buttons when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializeButtons);
        } else {
          // DOM is already ready
          initializeButtons();
        }

        // RATOON BUTTON FUNCTIONALITY
        function updateRatoonButtonState(growthData) {
          const ratoonBtn = document.getElementById('ratoonBtn');
          const ratoonTooltip = document.getElementById('ratoonBtnTooltip');
          
          if (!ratoonBtn) return;

          // Check if field status is 'harvested' (from database)
          const isHarvested = growthData && growthData.status === 'harvested';
          
          if (isHarvested) {
            ratoonBtn.disabled = false;
            ratoonBtn.title = 'Click to ratoon this field';
            if (ratoonTooltip) {
              ratoonTooltip.textContent = 'Click to ratoon this field';
              ratoonTooltip.classList.remove('text-gray-600');
              ratoonTooltip.classList.add('text-[var(--cane-600)]');
            }
          } else {
            ratoonBtn.disabled = true;
            ratoonBtn.title = 'Available only when field is harvested';
            if (ratoonTooltip) {
              ratoonTooltip.textContent = 'Available only when field is harvested';
              ratoonTooltip.classList.remove('text-[var(--cane-600)]');
              ratoonTooltip.classList.add('text-gray-600');
            }
          }
        }

        function normalizeVarietyName(variety) {
          if (!variety) return variety;
          
          // Handle aliases by extracting the first variety name
          const aliasPatterns = [
            { pattern: /^PS 1\s+or\s+VMC 84-947/i, normalized: 'PS 1' },
            { pattern: /^PS 2\s+or\s+VMC 88-354/i, normalized: 'PS 2' },
            { pattern: /^PS 3\s+or\s+VMC 84-524\s+or\s+CADP Sc1/i, normalized: 'PS 3' },
            { pattern: /^PS 4\s+or\s+VMC 95-152/i, normalized: 'PS 4' },
            { pattern: /^PS 5\s+or\s+VMC 95-09/i, normalized: 'PS 5' }
          ];
          
          for (const alias of aliasPatterns) {
            if (alias.pattern.test(variety)) {
              return alias.normalized;
            }
          }
          
          // Also check for individual variety names that might be in the alias string
          const varietyNames = Object.keys(RATOON_DURATIONS);
          for (const name of varietyNames) {
            if (variety.includes(name)) {
              return name;
            }
          }
          
          return variety.trim();
        }

        function getRatoonHarvestDateRange(variety, harvestDate) {
          if (!variety || !harvestDate) return null;
          
          const normalized = normalizeVarietyName(variety);
          const duration = RATOON_DURATIONS[normalized] || RATOON_DURATIONS[variety];
          if (!duration) {
            console.warn(`Variety ${variety} (normalized: ${normalized}) not found in ratoon durations`);
            return null;
          }
          
          // Convert months to days (using average 30.44 days per month)
          const daysPerMonth = 30.44;
          const minDays = Math.round(duration.min * daysPerMonth);
          const maxDays = Math.round(duration.max * daysPerMonth);
          
          const harvest = harvestDate instanceof Date ? harvestDate : new Date(harvestDate);
          
          return {
            earliest: new Date(harvest.getTime() + minDays * 24 * 60 * 60 * 1000),
            latest: new Date(harvest.getTime() + maxDays * 24 * 60 * 60 * 1000)
          };
        }

        async function handleRatoon() {
          if (!selectedFieldId) {
            showError('No field selected');
            return;
          }

          if (!currentUserId) {
            showError('User not authenticated');
            return;
          }

          const growthData = window.latestGrowthData;
          if (!growthData || growthData.status !== 'harvested') {
            showError('Field must be harvested before ratooning');
            return;
          }

          // Get harvest date for calculating expected harvest range
          const fieldRef = doc(db, 'fields', selectedFieldId);
          const fieldSnap = await getDoc(fieldRef);
          const fieldData = fieldSnap.data();
          const harvestDate = fieldData?.actualHarvestDate?.toDate?.() || fieldData?.actualHarvestDate;
          const variety = growthData?.variety || 'Unknown';

          // Calculate and display expected harvest date range
          let confirmMessage = 'Are you sure you want to ratoon this field? This will reset all growth tracking data.';
          if (harvestDate && variety) {
            const harvestRange = getRatoonHarvestDateRange(variety, harvestDate);
            if (harvestRange) {
              const earliestStr = harvestRange.earliest.toLocaleDateString();
              const latestStr = harvestRange.latest.toLocaleDateString();
              confirmMessage += `\n\nExpected Harvest Date Range: ${earliestStr} - ${latestStr}`;
            }
          }
          
          const confirmed = confirm(confirmMessage);
          if (!confirmed) return;

          try {
            const ratoonBtn = document.getElementById('ratoonBtn');
            ratoonBtn.disabled = true;
            const originalContent = ratoonBtn.innerHTML;
            ratoonBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Processing...';

            // Use backend handleRatooning function
            const result = await handleRatooning(currentUserId, selectedFieldId);
            
            if (result.success) {
              // Display success message with harvest date range if available
              let successMessage = 'Field successfully ratoon! Growth tracking has been reset.';
              if (harvestDate && variety) {
                const harvestRange = getRatoonHarvestDateRange(variety, harvestDate);
                if (harvestRange) {
                  const earliestStr = harvestRange.earliest.toLocaleDateString();
                  const latestStr = harvestRange.latest.toLocaleDateString();
                  successMessage += `\n\nExpected Harvest Date Range: ${earliestStr} - ${latestStr}`;
                }
              }
              showSuccess(successMessage);
              
              await displayFieldGrowthData(selectedFieldId);
            } else {
              showError('Failed to ratoon field. Please try again.');
            }
          } catch (error) {
            console.error('Error ratoon field:', error);
            showError(error.message || 'Failed to ratoon field. Please try again.');
          } finally {
            const ratoonBtn = document.getElementById('ratoonBtn');
            ratoonBtn.disabled = false;
            ratoonBtn.innerHTML = originalContent;
          }
        }

        // Initialize ratoon button event listener
        const ratoonBtn = document.getElementById('ratoonBtn');
        if (ratoonBtn) {
          ratoonBtn.addEventListener('click', handleRatoon);
        } else {
          console.warn('Ratoon button not found in DOM');
        }
      </script>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</body>

</html>