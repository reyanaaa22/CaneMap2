<!-- COMPLETE INPUT RECORD MODULE
This file handles ALL functionalities described in the PDF:
- Field dropdown fetched same way as GrowthTracker
- Dynamic Field Operation → Task Type → Dynamic Form
- Validation + confirmation modal
- Firebase save with success & error UI
- Structured data for easy filtering (operation, cost, date)
- Responsive, animated, themed UI
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CaneMap | Input Record</title>

  <!-- Icons & Tailwind -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <link rel="stylesheet" href="../../css/output.css" />

  <style>
    :root {
      --cane-50:#f0f7e9;--cane-100:#d4e8b3;--cane-200:#b8d97d;
      --cane-500:#2c5a0b;--cane-600:#3a7a0f;--cane-700:#2c5a0b;
    }

    .card{background:#fff;border:1px solid var(--cane-200);box-shadow:0 8px 24px rgba(0,0,0,.08);overflow:visible}
    .fade{animation:fade .25s ease}
    @keyframes fade{from{opacity:0;transform:translateY(5px)}to{opacity:1}}
    .btn{transition:.2s}
    .btn:hover{transform:translateY(-1px);box-shadow:0 10px 20px rgba(0,0,0,.15)}
    
    /* Custom select styling for consistent responsive dropdowns */
    .select-control{
      width:100%;
      max-width:100%;
      box-sizing:border-box;
      min-height:48px;
      padding:0.65rem 2.5rem 0.65rem 0.9rem;
      border:1px solid var(--cane-200);
      border-radius:0.85rem;
      background:#fff;
      color:#1f2937;
      font-weight:500;
      line-height:1.4;
      box-shadow:0 6px 16px rgba(32,73,8,0.08);
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      transition:box-shadow .2s ease,border-color .2s ease,transform .2s ease;
      background-image:
        linear-gradient(45deg,transparent 50%, var(--cane-600) 50%),
        linear-gradient(135deg,var(--cane-600) 50%, transparent 50%),
        linear-gradient(to right,transparent,transparent);
      background-position:calc(100% - 1.3rem) 55%,calc(100% - .9rem) 55%,0 0;
      background-size:0.45rem 0.45rem,0.45rem 0.45rem,100% 100%;
      background-repeat:no-repeat;
    }
    .select-control:focus{
      border-color:var(--cane-600);
      box-shadow:0 0 0 3px rgba(58,122,15,0.15);
      outline:none;
      transform:translateY(-1px);
    }
    .select-control option{
      font-weight:500;
      color:#111827;
      white-space:normal;
      word-break:break-word;
      text-overflow:ellipsis;
    }
    @media(max-width:640px){
      .select-control{
        min-height:52px;
        font-size:1rem;
        padding-right:2.75rem;
        border-radius:1rem;
        width:100%;
        max-width:100%;
        margin:0 auto;
      }
      .select-control option{
        font-size:0.95rem;
        white-space:normal;
      }
      .form-card,
      .card{
        padding-left:1rem;
        padding-right:1rem;
        overflow:visible;
      }
    }

    /* Custom dropdown shell */
    .custom-select-wrapper{
      position:relative;
      width:100%;
      margin-top:0.25rem;
    }
    .custom-select-trigger{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:0.65rem 0.9rem;
      min-height:48px;
      border:1px solid var(--cane-200);
      border-radius:0.85rem;
      background:#fff;
      color:#111827;
      font-weight:600;
      box-shadow:0 6px 16px rgba(32,73,8,0.08);
      transition:box-shadow .2s, border-color .2s, transform .2s;
    }
    .custom-select-trigger::after{
      content:"";
      width:0.5rem;
      height:0.5rem;
      border-right:2px solid var(--cane-600);
      border-bottom:2px solid var(--cane-600);
      transform:rotate(45deg);
      margin-left:0.5rem;
      transition:transform .2s;
    }
    .custom-select.open .custom-select-trigger{
      border-color:var(--cane-600);
      box-shadow:0 0 0 3px rgba(58,122,15,0.15);
    }
    .custom-select.open .custom-select-trigger::after{
      transform:rotate(-135deg);
    }
    .custom-select-list{
      position:absolute;
      top:calc(100% + 0.35rem);
      left:0;
      right:0;
      background:#fff;
      border-radius:1rem;
      border:1px solid #e5e7eb;
      box-shadow:0 18px 35px rgba(15,23,42,0.15);
      max-height:280px;
      overflow:auto;
      z-index:60;
      padding:0.35rem;
      display:none;
    }
    .custom-select.open .custom-select-list{
      display:block;
    }
    .custom-select-item{
      width:100%;
      text-align:left;
      border:none;
      background:transparent;
      padding:0.6rem 0.85rem;
      border-radius:0.65rem;
      font-weight:500;
      color:#111827;
      transition:background .15s, color .15s;
    }
    .custom-select-item:hover,
    .custom-select-item.active{
      background:rgba(58,122,15,0.08);
      color:var(--cane-700);
    }
    .custom-select-item:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }
    @media(max-width:640px){
      .custom-select-list{
        max-height:220px;
        border-radius:0.85rem;
      }
      .custom-select-trigger{
        min-height:52px;
      }
    }
    .custom-native-hidden{
      position:absolute !important;
      opacity:0 !important;
      pointer-events:none !important;
      width:0 !important;
      height:0 !important;
    }
    
    /* Modern Notification Banner Styles */
    .notification-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 9999;
      display: flex;
      justify-content: center;
      padding: 1rem;
      pointer-events: none;
    }
    
    .notification-content {
      background: white;
      border-radius: 1rem;
      padding: 1.25rem 1.5rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      max-width: 500px;
      width: 100%;
      display: flex;
      align-items: center;
      gap: 1rem;
      pointer-events: auto;
      transform: translateY(-120%);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .notification-content.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .notification-content.success {
      border-left: 4px solid #10b981;
    }
    
    .notification-content.error {
      border-left: 4px solid #ef4444;
    }
    
    .notification-content.loading {
      border-left: 4px solid #3b82f6;
    }
    
    .notification-content.info {
      border-left: 4px solid #3b82f6;
    }
    
    .notification-icon {
      flex-shrink: 0;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      animation: scaleIn 0.3s ease-out;
    }
    
    .notification-icon.success {
      background: #d1fae5;
      color: #10b981;
    }
    
    .notification-icon.error {
      background: #fee2e2;
      color: #ef4444;
    }
    
    .notification-icon.loading {
      background: #dbeafe;
      color: #3b82f6;
    }
    
    .notification-icon.info {
      background: #dbeafe;
      color: #3b82f6;
    }
    
    .notification-icon.loading i {
      animation: spin 1s linear infinite;
    }
    
    .notification-text {
      flex: 1;
    }
    
    .notification-title {
      font-weight: 600;
      font-size: 1rem;
      color: #111827;
      margin-bottom: 0.25rem;
    }
    
    .notification-message {
      font-size: 0.875rem;
      color: #6b7280;
      margin-bottom: 0.5rem;
    }
    
    .notification-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
    }
    
    .notification-btn {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .notification-btn-primary {
      background: var(--cane-700);
      color: white;
    }
    
    .notification-btn-primary:hover {
      background: var(--cane-600);
      transform: translateY(-1px);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .notification-btn-secondary {
      background: #f3f4f6;
      color: #374151;
    }
    
    .notification-btn-secondary:hover {
      background: #e5e7eb;
    }
    
    .notification-close {
      flex-shrink: 0;
      width: 1.75rem;
      height: 1.75rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #9ca3af;
      transition: all 0.2s;
      background: transparent;
      border: none;
    }
    
    .notification-close:hover {
      background: #f3f4f6;
      color: #374151;
    }
    
    @keyframes scaleIn {
      from {
        transform: scale(0);
      }
      to {
        transform: scale(1);
      }
    }
    
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
    
    @keyframes slideDown {
      from {
        transform: translateY(-120%);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    @keyframes slideUp {
      from {
        transform: translateY(0);
        opacity: 1;
      }
      to {
        transform: translateY(-120%);
        opacity: 0;
      }
    }
    
    /* Date input with current date dropdown */
    .date-input-wrapper {
      position: relative;
      width: 100%;
    }
    
    .current-date-dropdown {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      z-index: 100;
      display: none;
      animation: fade 0.2s ease;
    }
    
    .current-date-dropdown.show {
      display: block;
    }
    
    .current-date-option {
      padding: 0.75rem 1rem;
      cursor: pointer;
      transition: background 0.15s;
    }
    
    .current-date-option:hover {
      background: rgba(58, 122, 15, 0.08);
    }
    
    .current-date-option .date-label {
      font-weight: 600;
      color: var(--cane-700);
      font-size: 0.875rem;
      margin-bottom: 0.25rem;
    }
    
    .current-date-option .date-value {
      font-size: 0.75rem;
      color: #6b7280;
    }
    
    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9998;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .loading-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }
    
    .loading-spinner {
      width: 3.5rem;
      height: 3.5rem;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
  </style>
</head>

<body class="bg-gradient-to-br from-[var(--cane-50)] to-[var(--cane-100)] min-h-screen text-gray-800">

<header class="bg-white border-b">
  <div class="max-w-6xl mx-auto px-4 py-4 flex items-center gap-3">
    <a href="dashboard.html" class="text-[var(--cane-700)]"><i class="fa fa-arrow-left"></i></a>
    <h1 class="text-xl font-bold text-[var(--cane-700)]">Input Record</h1>
  </div>
</header>

<main class="max-w-6xl mx-auto p-4 space-y-6">

<!-- INFO -->
<div class="card rounded-xl p-4 text-sm">
  <i class="fa fa-circle-info text-[var(--cane-600)]"></i>
  All fields are required. Please input <b>N/A</b> or <b>0</b> if not applicable.
</div>

<!-- FORM CARD -->
<div class="card rounded-xl p-5 space-y-4 fade">

  <!-- FIELD -->
  <div id="fieldWrap">
    <label class="text-sm font-medium">Select a Field</label>
    <div class="custom-select" data-select-id="fieldSelect">
      <div class="custom-select-wrapper">
        <button type="button" class="custom-select-trigger" aria-haspopup="listbox" aria-expanded="false">
          <span class="custom-select-value">Select</span>
        </button>
        <div class="custom-select-list" role="listbox"></div>
      </div>
    </div>
    <select id="fieldSelect" class="custom-native-hidden"></select>
  </div>

  <!-- OPERATION -->
  <div id="operationWrap" class="hidden">
    <label class="text-sm font-medium">Field Operation</label>
    <div class="custom-select" data-select-id="operationSelect">
      <div class="custom-select-wrapper">
        <button type="button" class="custom-select-trigger" aria-haspopup="listbox" aria-expanded="false">
          <span class="custom-select-value">Select</span>
        </button>
        <div class="custom-select-list" role="listbox"></div>
      </div>
    </div>
    <select id="operationSelect" class="custom-native-hidden">
      <option value="">Select</option>
    </select>
  </div>

  <!-- TASK TYPE -->
  <div id="taskTypeWrap" class="hidden">
    <label class="text-sm font-medium">Task Type</label>
    <div class="custom-select" data-select-id="taskType">
      <div class="custom-select-wrapper">
        <button type="button" class="custom-select-trigger" aria-haspopup="listbox" aria-expanded="false">
          <span class="custom-select-value">Select</span>
        </button>
        <div class="custom-select-list" role="listbox"></div>
      </div>
    </div>
    <select id="taskType" class="custom-native-hidden"></select>
  </div>

  <!-- DYNAMIC FORM -->
  <div id="dynamicForm" class="grid grid-cols-1 md:grid-cols-2 gap-3 hidden"></div>

  <!-- OPTIONAL SUPPORTING SECTIONS -->
  
  <!-- Bought Items Section -->
  <div id="boughtItemsSection" class="hidden">
    <div class="border-t pt-4 mt-4">
      <div class="flex items-center justify-between mb-3">
        <h3 class="text-sm font-semibold">Bought Items (Optional)</h3>
        <button type="button" id="toggleBoughtItems" class="text-xs text-[var(--cane-700)] hover:underline">
          Show Section
        </button>
      </div>
      <div id="boughtItemsContent" class="hidden space-y-3">
        <div id="boughtItemsList"></div>
        <button type="button" id="addBoughtItemBtn" class="text-sm text-[var(--cane-700)] hover:underline">
          + Add Item
        </button>
      </div>
    </div>
  </div>

  <!-- Vehicle Updates Section -->
  <div id="vehicleUpdatesSection" class="hidden">
    <div class="border-t pt-4 mt-4">
      <div class="flex items-center justify-between mb-3">
        <h3 class="text-sm font-semibold">Vehicle / Transport Updates (Optional)</h3>
        <button type="button" id="toggleVehicleUpdates" class="text-xs text-[var(--cane-700)] hover:underline">
          Show Section
        </button>
      </div>
      <div id="vehicleUpdatesContent" class="hidden grid grid-cols-1 md:grid-cols-2 gap-3">
        <div>
          <label class="text-xs font-medium">Vehicle Type</label>
          <div class="custom-select" data-select-id="vehicleType">
            <div class="custom-select-wrapper">
              <button type="button" class="custom-select-trigger" aria-haspopup="listbox" aria-expanded="false">
                <span class="custom-select-value">Select</span>
              </button>
              <div class="custom-select-list" role="listbox"></div>
            </div>
          </div>
          <select id="vehicleType" class="custom-native-hidden">
            <option value="">Select</option>
            <option>Truck</option>
            <option>Tractor</option>
            <option>Other</option>
          </select>
        </div>
        <div>
          <label class="text-xs font-medium">Trips/Boxes</label>
          <input type="number" id="tripsBoxes" class="w-full mt-1 px-3 py-2 border rounded" />
        </div>
        <div>
          <label class="text-xs font-medium">Fuel Cost</label>
          <input type="number" step="0.01" id="vehicleFuelCost" class="w-full mt-1 px-3 py-2 border rounded" />
        </div>
        <div>
          <label class="text-xs font-medium">Labor Cost</label>
          <input type="number" step="0.01" id="vehicleLaborCost" class="w-full mt-1 px-3 py-2 border rounded" />
        </div>
        <div>
          <label class="text-xs font-medium">Total Cost</label>
          <input type="number" step="0.01" id="vehicleTotalCost" class="w-full mt-1 px-3 py-2 border rounded" readonly />
        </div>
        <div class="md:col-span-2">
          <label class="text-xs font-medium">Route / Field</label>
          <input type="text" id="vehicleRoute" class="w-full mt-1 px-3 py-2 border rounded" />
        </div>
      </div>
    </div>
  </div>

  <!-- SUBMIT -->
  <div class="pt-4 flex justify-end gap-3">
    <button type="button" id="savePartialBtn" class="btn bg-gray-500 text-white px-6 py-2 rounded-lg hover:bg-gray-600 transition">
      Save Record
    </button>
    <button type="button" id="submitBtn" class="btn bg-[var(--cane-700)] text-white px-6 py-2 rounded-lg">
      Done Record
    </button>
  </div>
</div>

</main>

<!-- CONFIRM MODAL -->
<div id="confirmModal" class="fixed inset-0 flex items-center justify-center bg-black/40 hidden z-50">
  <div class="bg-white rounded-xl p-6 w-[90%] max-w-md fade">
    <h3 class="font-semibold mb-2">Confirm Submission</h3>
    <p class="text-sm mb-4">Are all details correct?</p>
    <div class="flex justify-end gap-2">
      <button onclick="closeConfirm()" class="px-4 py-2 border rounded">Cancel</button>
      <button onclick="confirmSave()" class="px-4 py-2 bg-[var(--cane-700)] text-white rounded">Okay</button>
    </div>
  </div>
</div>

<!-- Modern Notification Banner -->
<div id="notificationBanner" class="notification-banner">
  <div id="notificationContent" class="notification-content">
    <div id="notificationIcon" class="notification-icon">
      <i id="notificationIconI" class="fas"></i>
    </div>
    <div class="notification-text">
      <div id="notificationTitle" class="notification-title"></div>
      <div id="notificationMessage" class="notification-message"></div>
      <div id="notificationActions" class="notification-actions"></div>
    </div>
    <button id="notificationClose" class="notification-close" onclick="hideNotification()">
      <i class="fas fa-times"></i>
    </button>
  </div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="loading-overlay">
  <div class="loading-spinner"></div>
</div>

<script type="module">
import { auth, db } from '../../backend/Common/firebase-config.js'
import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js'
import { collection, getDocs, addDoc, serverTimestamp, query, where, getDoc, doc, deleteDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js'
import { initHandlerOfflineSync, getOnlineStatus, wasOnInputRecords } from '../../backend/Handler/offline-input-sync.js'
import { addPendingRecord } from '../../backend/Handler/offline-input-storage.js'

// Initialize offline sync for Input Records page
initHandlerOfflineSync();

let uid=null
let pendingPayload=null

const customSelectInstances = new Map();

const closeAllCustomSelects = (except) => {
  document.querySelectorAll('.custom-select.open').forEach(container => {
    if (container !== except) {
      container.classList.remove('open');
      const trigger = container.querySelector('.custom-select-trigger');
      if (trigger) trigger.setAttribute('aria-expanded', 'false');
    }
  });
};

function initializeCustomSelect(selectElement) {
  if (!selectElement || selectElement.dataset.customInitialized === 'true') return;
  const container = document.querySelector(`.custom-select[data-select-id="${selectElement.id}"]`);
  if (!container) return;

  selectElement.dataset.customInitialized = 'true';
  const trigger = container.querySelector('.custom-select-trigger');
  const valueEl = container.querySelector('.custom-select-value');
  const listEl = container.querySelector('.custom-select-list');

  const close = () => {
    container.classList.remove('open');
    trigger.setAttribute('aria-expanded', 'false');
  };

  const open = () => {
    closeAllCustomSelects(container);
    container.classList.add('open');
    trigger.setAttribute('aria-expanded', 'true');
  };

  const updateSelectedLabel = () => {
    const option = selectElement.options[selectElement.selectedIndex];
    valueEl.textContent = option ? option.textContent : 'Select';
  };

  const renderOptions = () => {
    listEl.innerHTML = '';
    const fragment = document.createDocumentFragment();
    Array.from(selectElement.options).forEach(option => {
      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'custom-select-item';
      item.textContent = option.textContent || 'Select';
      item.dataset.value = option.value;
      if (option.disabled) item.disabled = true;
      if (option.value === selectElement.value) item.classList.add('active');
      item.addEventListener('click', () => {
        if (option.disabled) return;
        selectElement.value = option.value;
        selectElement.dispatchEvent(new Event('change', { bubbles: true }));
        close();
      });
      fragment.appendChild(item);
    });
    listEl.appendChild(fragment);
    updateSelectedLabel();
  };

  trigger.addEventListener('click', (e) => {
    e.preventDefault();
    // Prevent opening if the select is disabled
    if (selectElement.disabled) return;
    container.classList.contains('open') ? close() : open();
  });

  document.addEventListener('click', (e) => {
    if (!container.contains(e.target)) {
      close();
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') close();
  });

  selectElement.addEventListener('change', () => {
    updateSelectedLabel();
    listEl.querySelectorAll('.custom-select-item').forEach(item => {
      item.classList.toggle('active', item.dataset.value === selectElement.value);
    });
  });

  const observer = new MutationObserver(renderOptions);
  observer.observe(selectElement, { childList: true, subtree: true });

  renderOptions();
  customSelectInstances.set(selectElement.id, { renderOptions, updateSelectedLabel });
}

function initializeAllCustomSelects() {
  ['fieldSelect','operationSelect','taskType','vehicleType'].forEach(id => {
    const el = document.getElementById(id);
    if (el) initializeCustomSelect(el);
  });
}

initializeAllCustomSelects();

function getCustomSelectTemplate(id, optionsHTML, placeholder = 'Select', extraAttrs = '', extraClasses = '') {
  return `
    <div class="custom-select" data-select-id="${id}">
      <div class="custom-select-wrapper">
        <button type="button" class="custom-select-trigger" aria-haspopup="listbox" aria-expanded="false">
          <span class="custom-select-value">${placeholder}</span>
        </button>
        <div class="custom-select-list" role="listbox"></div>
      </div>
    </div>
    <select id="${id}" class="custom-native-hidden ${extraClasses}" ${extraAttrs}>
      ${optionsHTML}
    </select>
  `;
}

function showCenterMessage(msg) {
  const existing = document.getElementById('centerMsgModal');
  if(existing) existing.remove();

  const modal = document.createElement('div');
  modal.id = 'centerMsgModal';
  modal.className = 'fixed inset-0 flex items-center justify-center bg-black/40 z-50';
  modal.innerHTML = `
    <div class="bg-white rounded-xl p-6 w-[90%] max-w-sm text-center">
      <h3 class="font-semibold mb-4 text-lg">${msg}</h3>
      <button id="closeCenterMsg" class="px-4 py-2 bg-[var(--cane-700)] text-white rounded">Okay</button>
    </div>
  `;
  document.body.appendChild(modal);

  document.getElementById('closeCenterMsg').onclick = () => modal.remove();
}


// Task name aliases mapping (display name → taskFieldMap key)
// Maps Visayas task type names (with Cebuano) to taskFieldMap keys
const taskNameAliases = {
  'Clearing (Paglimpyo sa uma)': 'Land Clearing',
  'Plowing (Arado / Araro)': 'Plowing',
  'Harrowing (Suyod)': 'Harrowing',
  'Field Leveling (Pagpatag sa uma)': 'Field Leveling',
  'Furrowing / Trenching (Paghimo ug tudling)': 'Furrow Making',
  'Seed Cane Preparation (Pag-andam sa binhi sa tubo)': 'Seed Cane Preparation',
  'Planting Operation (Pagtanom sa tubo)': 'Planting Operation',
  'First Dose Fertilization – Furrow Application (Unang Abono – sa tudling)': 'Pre-Planting Fertilization (basal)',
  'Germination Monitoring (Pagmonitor sa pagturok)': 'Germination Monitoring',
  'Gap Filling / Replanting (Pagpuli sa wala miturok)': 'Replanting Operation',
  'Weeding (Pagpananom / Paglimpyo sa sagbot)': 'Weeding',
  'First Dose Fertilization – After Emergence (Unang Abono)': 'Post-Planting Fertilization',
  'Hilling-up / Off-barring (Pagtabon sa gamot)': 'Earthing-Up',
  'Second Dose Fertilization (Ikaduhang Abono)': 'Post-Planting Fertilization',
  'Irrigation / Watering (Pagpatubig)': 'Irrigation',
  'Brushing / Light Detrashing (Pagpanitan – magaan)': 'Side Cleaning',
  'Ripener Application (Pagbutang og ripener)': 'Ripener Application',
  'Crop Monitoring (Pagbantay sa kahamtong)': 'Growth Monitoring',
  'Detrashing / Brushing (Pagpanitan sa uga nga dahon)': 'Detrashing',
  'Harvesting (Ani sa Tubo)': 'Harvesting',
  'Replanting Operation (Pag-usab og tanom)': 'Replanting Operation'
};

// Auto-derive growth stage from Operation + Task Type
function deriveGrowthStage(operation, taskType) {
  if (!operation || !taskType) return null;
  
  // Post-Planting tasks map to specific growth stages based on task type
  if (operation === 'Post-Planting') {
    const taskToStage = {
      // Germination & Early Growth
      'Germination Monitoring (Pagmonitor sa pagturok)': 'Germination & Early Growth',
      'Gap Filling / Replanting (Pagpuli sa wala miturok)': 'Germination & Early Growth',
      
      // Tillering Stage
      'Weeding (Pagpananom / Paglimpyo sa sagbot)': 'Tillering Stage',
      'First Dose Fertilization – After Emergence (Unang Abono)': 'Tillering Stage',
      'Hilling-up / Off-barring (Pagtabon sa gamot)': 'Tillering Stage',
      
      // Stem Elongation & Grand Growth
      'Second Dose Fertilization (Ikaduhang Abono)': 'Stem Elongation & Grand Growth',
      'Irrigation / Watering (Pagpatubig)': 'Stem Elongation & Grand Growth',
      'Brushing / Light Detrashing (Pagpanitan – magaan)': 'Stem Elongation & Grand Growth',
      
      // Ripening & Maturation
      'Ripener Application (Pagbutang og ripener)': 'Ripening & Maturation',
      'Crop Monitoring (Pagbantay sa kahamtong)': 'Ripening & Maturation'
    };
    return taskToStage[taskType] || 'Stem Elongation & Grand Growth'; // Default fallback
  }
  
  // Direct operation mappings
  if (operation === 'Pre-Planting') return 'Land Preparation (Before Planting)';
  if (operation === 'Planting') return 'Planting (Panahon sa Pagtanom)';
  if (operation === 'Harvesting') return 'Harvesting (Ani sa Tubo)';
  if (operation === 'Detrashing') return 'Detrashing Stage';
  if (operation === 'Replanting') return 'Replanting Stage';
  
  return null; // Should not happen
}

// Direct Operation → Task Types mapping (Visayas farming practices)
const operationToTasks = {
  'Pre-Planting': [
    'Clearing (Paglimpyo sa uma)',
    'Plowing (Arado / Araro)',
    'Harrowing (Suyod)',
    'Field Leveling (Pagpatag sa uma)',
    'Furrowing / Trenching (Paghimo ug tudling)',
    'Seed Cane Preparation (Pag-andam sa binhi sa tubo)'
  ],
  'Planting': [
    'Planting Operation (Pagtanom sa tubo)',
    'First Dose Fertilization – Furrow Application (Unang Abono – sa tudling)'
  ],
  'Post-Planting': [
    'Germination Monitoring (Pagmonitor sa pagturok)',
    'Gap Filling / Replanting (Pagpuli sa wala miturok)',
    'Weeding (Pagpananom / Paglimpyo sa sagbot)',
    'First Dose Fertilization – After Emergence (Unang Abono)',
    'Hilling-up / Off-barring (Pagtabon sa gamot)',
    'Second Dose Fertilization (Ikaduhang Abono)',
    'Irrigation / Watering (Pagpatubig)',
    'Brushing / Light Detrashing (Pagpanitan – magaan)',
    'Ripener Application (Pagbutang og ripener)',
    'Crop Monitoring (Pagbantay sa kahamtong)'
  ],
  'Detrashing': [
    'Detrashing / Brushing (Pagpanitan sa uga nga dahon)'
  ],
  'Harvesting': [
    'Harvesting (Ani sa Tubo)'
  ],
  'Replanting': [
    'Replanting Operation (Pag-usab og tanom)'
  ],
  'Ratooning': [] // Special - no task types, handled separately
};

// Legacy operationMap for backward compatibility with taskFieldMap
const operationMap = {
  'Pre-Planting': ['Land Assessment', 'Land Clearing', 'Sub-Soiling', 'Soil Analysis', 'Plowing', 'Harrowing', 'Furrow Making', 'Lime Application', 'Pre-Planting Fertilization (basal)', 'Seed Cane Preparation'],
  'Planting': ['Planting Operation', 'Replanting Operation'],
  'Post-Planting': ['Germination Monitoring', 'Post-Planting Fertilization', 'Cultivation', 'Weeding', 'Drainage', 'Irrigation', 'Side Cleaning', 'Control of Pest & Diseases', 'Earthing-Up', 'Growth Monitoring', 'Pre-Harvest Assessment', 'Harvesting', 'Hauling', 'Ratooning'],
  'Vehicle Updates': ['Vehicle Updates']
};

// FULL TASK → INPUT FIELD MAP (from PDF)
const taskFieldMap = {
"Land Assessment": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { id:'fieldArea', label:'Field Area (hectare)', type:'number', step:'0.01' },

  { id:'soilType', label:'Soil Type', type:'select',
    options:[
      'Clay',
      'Loam',
      'Sandy',
      'Silty',
      'Clay Loam',
      'Sandy Loam',
      'Peat',
      'Others'
    ] 
  },

{ 
  id:'drainage', 
  label:'Drainage Condition', 
  type:'select',
  options:[
    'Well Drained: Roots healthy, max growth and yield',
    'Moderately Drained: Growth okay but slower sometimes',
    'Poorly Drained: Roots suffocate, yield drops'
  ] 
},

  { id:'previousCrop', label:'Previous Crop', type:'select',
    options:[
      'Sugarcane',
      'Rice',
      'Corn',
      'Vegetables',
      'Fallow',
      'Others'
    ] 
  },

],


  "Land Clearing": [
    { id:'startDate', label:'Start Date', type:'date' },
    { id:'endDate', label:'End Date', type:'date' },

    { id:'method', label:'Clearing Method', type:'select',
      options:['Manual','Mechanical','Animal-Drawn','Herbicide'] },

    { id:'equipment', label:'Equipment Used', type:'text' },
    { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
    { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

  ],


"Sub-Soiling": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { id:'depth', label:'Depth (cm)', type:'number' },
  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select',
    options:[
      'Tractor with Subsoiler/Shank',
      'Animal-Drawn',
      'Ripper/Chisel Plow',
      'Manual Tools',
      'Others'
    ]
  },
  { id:'operators', label:'Number of Operators', type:'number' },
  { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

],

"Soil Analysis": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { id:'samplingDepth', label:'Sampling Depth (cm)', type:'number', step:'0.01' },
  { 
    id:'soilTexture', 
    label:'Soil Texture', 
    type:'select',
    options:[
      'Clay',
      'Silt',
      'Sand',
      'Loam',
      'Sandy Loam',
      'Clay Loam',
      'Silty Clay',
      'Peat / Organic',
      'Others'
    ]
  },
  { id:'pH', label:'Soil pH', type:'number', step:'0.01' },
  { id:'organicMatter', label:'Organic Matter (%)', type:'number', step:'0.01' },
  { id:'nitrogen', label:'Nitrogen (N) ppm', type:'number', step:'0.01' },
  { id:'phosphorus', label:'Phosphorus (P) ppm', type:'number', step:'0.01' },
  { id:'potassium', label:'Potassium (K) ppm', type:'number', step:'0.01' },
  { id:'calcium', label:'Calcium (Ca) ppm', type:'number', step:'0.01' },
  { id:'magnesium', label:'Magnesium (Mg) ppm', type:'number', step:'0.01' },

],


"Plowing": [
    { id:'startDate', label:'Start Date', type:'date' },
    { id:'endDate', label:'End Date', type:'date' },
    { 
      id:'equipment', 
      label:'Equipment / Method', 
      type:'select', 
      options:['Manual','Animal-Drawn','Mechanical','Others'] 
    },
    { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
    { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
    { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
  ],

"Harrowing": [
    { id:'startDate', label:'Start Date', type:'date' },
    { id:'endDate', label:'End Date', type:'date' },
    { id:'passes', label:'Passes (No. of times harrowed)', type:'number' },
    { 
      id:'equipment', 
      label:'Equipment / Method', 
      type:'select', 
      options:['Manual','Animal-Drawn','Mechanical','Others'] 
    },
    { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
    { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
    { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
  ],

"Field Leveling": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { 
    id:'method', 
    label:'Method Used', 
    type:'select', 
    options:['Manual', 'Animal-Drawn', 'Mechanical', 'Others'] 
  },
  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select', 
    options:['Manual Tools', 'Animal-Drawn Leveler', 'Tractor with Leveler', 'Laser Leveler', 'Others'] 
  },
  { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
    { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
  ],

"Furrow Making": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { 
    id:'method', 
    label:'Method', 
    type:'select', 
    options:['Manual', 'Animal-Drawn', 'Mechanical', 'Others'] 
  },
  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select', 
    options:['Manual Tools', 'Animal-Drawn Plow', 'Tractor with Furrower', 'Others'] 
  },
  { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
  ],

"Lime Application": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'limeType', 
    label:'Lime Type', 
    type:'select', 
    options:[
      'Agricultural Lime (Calcitic)',
      'Dolomitic Lime',
      'Pelletized Lime',
      'Others'
    ] 
  },

  { id:'amountApplied', label:'Amount Applied (kg/ha)', type:'number', step:'0.01' },

  { 
    id:'applicationMethod', 
    label:'Application Method', 
    type:'select', 
    options:[
      'Broadcast', 
      'Banded', 
      'Incorporated', 
      'Others'
    ] 
  },

  { id:'operators', label:'Number of Operators', type:'number' },

  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select', 
    options:[
      'Tractor with Spreader', 
      'Manual Spreading', 
      'Animal-Drawn', 
      'Others'
    ] 
  },

  { id:'materialCost', label:'Material Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

],


"Pre-Planting Fertilization (basal)": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { id:'fertilizerType', label:'Fertilizer Type', type:'select',
    options:[
      'Urea (46-0-0)',
      'Ammonium Sulfate (21-0-0)',
      'Complete (14-14-14)',
      'DAP (18-46-0)',
      'MOP (0-0-60)',
      '16-20-20',
      'Organic Fertilizer',
      'Liquid Fertilizer/BMOs',
      'Mudpress',
      'Rock Phosphate',
      'Others'
    ] 
  },

  { id:'amount', label:'Amount Applied (kg)', type:'number', step:'0.01' },

  { id:'applicationMethod', label:'Application Method', type:'select',
    options:[
      'Broadcasting',
      'Banding',
      'Side Dressing',
      'Foliar Spray',
      'Mudpress Application',
      'Others'
    ] 
  },

  { id:'fertilizerCost', label:'Fertilizer Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],


"Seed Cane Preparation": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'variety', 
    label:'Variety', 
    type:'select',
    options:[
      'PHIL 99-1793',
      'PHIL 80-13',
      'VMC 84-524',
      'VMC 84-947',
      'PHIL 93-1601',
      'PHIL 94-0913',
      'PHIL 92-0577',
      'Others'
    ]
  },
  { id:'seedSource', label:'Seed Source', type:'text' },
  { id:'seedAge', label:'Seed Age (months)', type:'number' },

  { 
    id:'treatment', 
    label:'Treatment', 
    type:'select', 
    options:[
      'None',
      'Fungicide',
      'Insecticide',
      'Hot Water Treatment',
      'Biological Treatment',
      'Others'
    ]
  },

  { id:'quantity', label:'Quantity Prepared', type:'number' },
  { id:'materialCost', label:'Material Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],

"Planting Operation": [
  { id:'startDate', label:'Date Planted', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { 
    id:'variety', 
    label:'Variety', 
    type:'select',
    options:[
      'K 88-65 — 11–13 months',
      'K 88-87 — 11–13 months',
      'PS 1 / VMC 84-947 — 10–11 months',
      'PS 2 / VMC 88-354 — 8–9 months',
      'PS 3 / VMC 84-524 / CADP Sc1 — 9–10 months',
      'PS 4 / VMC 95-152 — 9–11 months',
      'PS 5 / VMC 95-09 — 9–11 months',
      'PSR 2000-161 — 10–11 months',
      'PSR 2000-343 — 10–11 months',
      'PSR 2000-34 — 10–11 months',
      'PSR 97-41 — 10 months',
      'PSR 97-45 — 9–10 months',
      'PS 862 — 9–11 months',
      'VMC 71-39 — 9–11 months',
      'VMC 84-549 — 9 months',
      'VMC 86-550 — 10–11 months',
      'VMC 87-599 — 9–11 months',
      'VMC 87-95 — 9–10 months',
      'Others'
    ]
  },
  { id:'expectedHarvestDate', label:'Expected Harvest Date (auto-calculated)', type:'text', readonly: true },
  { id:'seedRate', label:'Seed Rate (canepoints/ha)', type:'number', step:'0.01', readonly: true },
  { id:'numberOfSetts', label:'Number of Setts', type:'number', step:'0.01' },
  { id:'totalCaneRequired', label:'Total Cane Required (auto-calculated)', type:'number', step:'0.01', readonly: true, computed: 'numberOfSetts * seedRate' },

  // Planting of cane points
  { 
    id:'plantingMethod', 
    label:'Planting Method', 
    type:'select', 
    options:['Manual','Mechanical','Others'] 
  },
  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select', 
    options:['Manual Tools', 'Planting Machine', 'Tractor with Planter', 'Others'] 
  },
  { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],

"Replanting Operation": [
  { id:'startDate', label:'Date Planted', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { 
    id:'variety', 
    label:'Variety', 
    type:'select',
    options:[
      'K 88-65 — 11–13 months',
      'K 88-87 — 11–13 months',
      'PS 1 / VMC 84-947 — 10–11 months',
      'PS 2 / VMC 88-354 — 8–9 months',
      'PS 3 / VMC 84-524 / CADP Sc1 — 9–10 months',
      'PS 4 / VMC 95-152 — 9–11 months',
      'PS 5 / VMC 95-09 — 9–11 months',
      'PSR 2000-161 — 10–11 months',
      'PSR 2000-343 — 10–11 months',
      'PSR 2000-34 — 10–11 months',
      'PSR 97-41 — 10 months',
      'PSR 97-45 — 9–10 months',
      'PS 862 — 9–11 months',
      'VMC 71-39 — 9–11 months',
      'VMC 84-549 — 9 months',
      'VMC 86-550 — 10–11 months',
      'VMC 87-599 — 9–11 months',
      'VMC 87-95 — 9–10 months',
      'Others'
    ]
  },
  { id:'expectedHarvestDate', label:'Expected Harvest Date (auto-calculated)', type:'text', readonly: true },
  { id:'seedRate', label:'Seed Rate (canepoints/ha)', type:'number', step:'0.01', readonly: true },
  { id:'numberOfSetts', label:'Number of Setts', type:'number', step:'0.01' },
  { id:'totalCaneRequired', label:'Total Cane Required (auto-calculated)', type:'number', step:'0.01', readonly: true, computed: 'numberOfSetts * seedRate' },

  // Planting of cane points
  { 
    id:'plantingMethod', 
    label:'Planting Method', 
    type:'select', 
    options:['Manual','Mechanical','Others'] 
  },
  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select', 
    options:['Manual Tools', 'Planting Machine', 'Tractor with Planter', 'Others'] 
  },
  { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],

"Germination Monitoring": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { id:'germinationRate', label:'Germination Rate (%)', type:'number', step:'0.01' },
  { id:'cropAge', label:'Crop Age (days)', type:'number' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],

"Growth Monitoring": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { id:'cropAge', label:'Crop Age (days)', type:'number' },
  { id:'height', label:'Average Height (cm)', type:'number', step:'0.01' },
  { id:'tillersPerHill', label:'Tillers per Hill', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],

"Ripener Application": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { 
    id:'ripenerType', 
    label:'Ripener Type', 
    type:'select',
    options:[
      'Ethephon',
      'Glyphosate',
      'Sodium Chlorate',
      'Calcium Carbide',
      'Others'
    ]
  },
  { id:'dosage', label:'Dosage (ml/L or kg/ha)', type:'number', step:'0.01' },
  { 
    id:'applicationMethod', 
    label:'Application Method', 
    type:'select',
    options:[
      'Foliar Spray',
      'Aerial Application',
      'Ground Application',
      'Others'
    ]
  },
  { id:'areaCovered', label:'Area Covered (ha)', type:'number', step:'0.01', autoFill: true },
  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select', 
    options:['Manual Sprayer', 'Tractor-mounted Sprayer', 'Aerial Sprayer', 'Others'] 
  },
  { id:'materialCost', label:'Material Cost', type:'number', step:'0.01' },
  { id:'fuelCost', label:'Fuel Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],

"Pre-Harvest Assessment": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  { id:'cropAge', label:'Crop Age (days)', type:'number' },
  { id:'maturityLevel', label:'Maturity Level', type:'select',
    options:['Early Mature', 'Mature', 'Over Mature']
  },
  { id:'estimatedYield', label:'Estimated Yield (tc/ha)', type:'number', step:'0.01' },
  { id:'brix', label:'Brix (%)', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],

"Post-Planting Fertilization": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { id:'fertilizerType', label:'Fertilizer Type', type:'select',
    options:[
      'Urea (46-0-0)',
      'Ammonium Sulfate (21-0-0)',
      'Complete (14-14-14)',
      'DAP (18-46-0)',
      'MOP (0-0-60)',
      '16-20-20',
      'Organic Fertilizer',
      'Liquid Fertilizer/BMOs',
      'Mudpress',
      'Rock Phosphate',
      'Others'
    ] 
  },

  { id:'amount', label:'Amount Applied (kg)', type:'number', step:'0.01' },

  { id:'applicationMethod', label:'Application Method', type:'select',
    options:[
      'Broadcasting',
      'Banding',
      'Side Dressing',
      'Foliar Spray',
      'Mudpress Application',
      'Others'
    ] 
  },

  { id:'fertilizerCost', label:'Fertilizer Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' }
],

"Cultivation": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'method', 
    label:'Method', 
    type:'select', 
    options:['Manual','Animal-Drawn','Tractor/Mechanical','Others'] 
  },

  { 
    id:'cultivationOperation', 
    label:'Cultivation Operation', 
    type:'select', 
    options:[
      'Ridge-Busting',
      '1st Off-Barring',
      '2nd Off-Barring',
      'On-Barring / Barring',
      'Hilling-Up',
      'Off-Barring',
      'Middle Ridge',
      'Cut-Away',
      'Chipper',
      'Chisel',
      'Others'
    ]
  },

  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

],

"Weeding": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'method', 
    label:'Weeding Method', 
    type:'select', 
    options:['Manual Weeding','Chemical Weeding','Others'] 
  },

  // Only shown if Chemical Weeding is selected
  { 
    id:'herbicide', 
    label:'Herbicide / Chemical Name', 
    type:'select',
    options:[
      'Glyphosate',
      'Paraquat',
      '2,4-D',
      'Atrazine',
      'Simazine',
      'Others'
    ],
    dependsOn:{ field:'method', values:['Chemical Weeding'] } 
  },

  { id:'dosage', label:'Dosage', type:'number', step:'0.01', dependsOn:{ field:'method', values:['Chemical Weeding'] }, hasUnit: true, unitOptions: ['Liter', 'Kilogram'] },

  { id:'areaCovered', label:'Area Covered (ha)', type:'number', step:'0.01', autoFill: true },

  // Costs
  { id:'chemicalCost', label:'Chemical Cost', type:'number', step:'0.01', dependsOn:{ field:'method', values:['Chemical Weeding'] } },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

],


"Drainage": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },
  
  { 
    id:'drainageType', 
    label:'Type of Drainage', 
    type:'select',
    options:[
      'Open Ditch',
      'Subsurface / Tile',
      'Contour Drain',
      'Raised Bed',
      'Others'
    ]
  },

  { id:'workers', label:'Number of Workers', type:'number' },

  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select',
    options:[
      'Excavator',
      'Backhoe',
      'Tractor',
      'Manual Tools',
      'Others'
    ]
  },

  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'materialCost', label:'Material / Construction Cost', type:'number', step:'0.01' },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

],


"Irrigation": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'irrigationMethod', 
    label:'Irrigation Method', 
    type:'select',
    options:[
      'Flooding',
      'Furrow',
      'Sprinkler',
      'Drip',
      'Others'
    ]
  },

  { 
    id:'waterSource', 
    label:'Water Source', 
    type:'select',
    options:[
      'Canal',
      'Well / Pump',
      'Rainfed',
      'River / Stream',
      'Others'
    ]
  },
  { id:'workers', label:'Number of Workers', type:'number' },

  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select',
    options:[
      'Pump',
      'Sprinkler System',
      'Irrigation Canal Tools',
      'Manual Tools',
      'Others'
    ]
  },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'materialCost', label:'Material / Pump Cost', type:'number', step:'0.01' },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

],


"Side Cleaning": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'cleaningMethod', 
    label:'Cleaning Method', 
    type:'select',
    options:[
      'Manual',
      'Mechanical',
      'Herbicide / Chemical',
      'Others'
    ]
  },

  { 
    id:'chemicalUsed', 
    label:'Herbicide / Chemical Name', 
    type:'select',
    options:[
      'Glyphosate',
      'Paraquat',
      '2,4-D',
      'Atrazine',
      'Others'
    ],
    dependsOn: { field:'cleaningMethod', values:['Herbicide / Chemical'] }
  },

  { id:'dosage', label:'Dosage (L or kg)', type:'number', step:'0.01', dependsOn: { field:'cleaningMethod', values:['Herbicide / Chemical'] } },
  { id:'areaCovered', label:'Area Covered (ha)', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'chemicalCost', label:'Chemical Cost', type:'number', step:'0.01', dependsOn: { field:'cleaningMethod', values:['Herbicide / Chemical'] } },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

],

"Control of Pest & Diseases": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'pestDisease', 
    label:'Pest / Disease Identified', 
    type:'select', 
    options:[
      'Borer',
      'Rodents',
      'Others'
    ]
  },

  { id:'affectedArea', label:'Affected Area (ha)', type:'number', step:'0.01' },

  { 
    id:'severity', 
    label:'Severity', 
    type:'select', 
    options:['Low','Medium','High'] 
  },

  { 
    id:'controlMethod', 
    label:'Control Method', 
    type:'select',
    options:[
      'Trichogramma Release',
      'Rodent Control',
      'Chemical Spray',
      'Others'
    ]
  },
{ 
  id:'chemical', 
  label:'Chemical Used', 
  type:'select',
  options:[
    'Glyphosate',
    'Chlorpyrifos',
    'Carbofuran',
    'Imidacloprid',
    'Thiamethoxam',
    'Mancozeb',
    'Others'
  ],
  dependsOn:{ field:'controlMethod', values:['Chemical Spray'] }
},

  { 
    id:'dosage', 
    label:'Dosage (kg/L per ha)', 
    type:'number',
    step:'0.01',
    dependsOn:{ field:'controlMethod', values:['Chemical Spray'] }
  },


  { id:'areaTreated', label:'Area Treated (ha)', type:'number', step:'0.01' },
  { id:'materialCost', label:'Material Cost', type:'number', step:'0.01' },
  { id:'laborCost', label:'Labor Cost', type:'number', step:'0.01', enhanced: true },
  { id:'totalCost', label:'Total Cost', type:'number', step:'0.01' },

],

"Earthing-Up": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'method', 
    label:'Method Used', 
    type:'select',
    options:[
      'Manual',
      'Animal-Drawn',
      'Mechanical (Tractor)',
      'Others'
    ]
  },

  { 
    id:'depth', 
    label:'Soil Heaping Depth (cm)', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'rowCoverage', 
    label:'Rows Covered', 
    type:'number'
  },

  { 
    id:'fuelCost', 
    label:'Fuel Cost', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'laborCost', 
    label:'Labor Cost', 
    type:'number',
    step:'0.01',
    enhanced: true
  },

  { 
    id:'totalCost', 
    label:'Total Cost', 
    type:'number',
    step:'0.01'
  },

],

"Detrashing": [
  { id:'startDate', label:'Start Date (Petsa Sugod)', type:'date' },
  { id:'endDate', label:'End Date (Petsa Tapos)', type:'date' },
  
  { 
    id:'areaCovered', 
    label:'Area Covered (Natabunan nga luna)', 
    type:'number', 
    step:'0.01',
    autoFill: true
  },
  
  { 
    id:'method', 
    label:'Method (Paagi sa Pagpanitan)', 
    type:'select',
    options:[
      'Manual (Manu-mano)',
      'Mechanical (Makinarya)',
      'Others'
    ]
  },
  
  
  { 
    id:'laborCost', 
    label:'Labor Cost', 
    type:'number', 
    step:'0.01',
    enhanced: true
  },
  
  { 
    id:'equipmentUsed', 
    label:'Equipment Used (Gigamit nga ekipo)', 
    type:'text',
    placeholder: 'e.g., bolo, sickle, brush cutter'
  },
  
  { 
    id:'totalCost', 
    label:'Total Cost', 
    type:'number', 
    step:'0.01'
  }

],

"Harvesting": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'harvestMethod', 
    label:'Harvesting Method', 
    type:'select',
    options:[
      'Manual',
      'Mechanical',
      'Manual + Mechanical',
      'Others'
    ]
  },

  { 
    id:'caneType', 
    label:'Cane Type', 
    type:'select',
    options:[
      'Plant Cane',
      'Ratoon Cane'
    ]
  },

  { 
    id:'yieldTcHa', 
    label:'Yield (tc/ha)', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'areaHarvested', 
    label:'Area Harvested (ha)', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'totalCaneYield', 
    label:'Total Cane Yield (tons)', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'laborCost', 
    label:'Labor Cost', 
    type:'number', 
    step:'0.01',
    enhanced: true
  },

  { 
    id:'transportUsed', 
    label:'Transport Used', 
    type:'select',
    options:[
      'Truck',
      'Tractor + Trailer',
      'Animal-Drawn Cart',
      'Others'
    ]
  },

  { 
    id:'harvestCost', 
    label:'Harvest Cost (Cutting & Loading)', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'transportCost', 
    label:'Transport Cost', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'totalCost', 
    label:'Total Cost', 
    type:'number',
    step:'0.01'
  },


], 

"Hauling": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'caneType', 
    label:'Cane Type', 
    type:'select',
    options:[
      'Plant Cane',
      'Ratoon Cane'
    ]
  },

  { 
    id:'haulingType', 
    label:'Hauling Type', 
    type:'select',
    options:[
      'Infield Hauling',
      'Mill / Outfield Hauling'
    ]
  },

  { 
    id:'transportUsed', 
    label:'Transport Used', 
    type:'select',
    options:[
      'Truck',
      'Tractor + Trailer',
      'Animal-Drawn Cart',
      'Others'
    ]
  },

  { 
    id:'distance', 
    label:'Distance Covered (km)', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'caneLoaded', 
    label:'Cane Loaded (tons)', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'fuelCost', 
    label:'Fuel Cost', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'laborCost', 
    label:'Labor Cost', 
    type:'number',
    step:'0.01',
    enhanced: true
  },

  { 
    id:'haulingExpense', 
    label:'Total Hauling Expense', 
    type:'number',
    step:'0.01'
  },


],

"Ratooning": [
  { id:'startDate', label:'Start Date', type:'date' },
  { id:'endDate', label:'End Date', type:'date' },

  { 
    id:'ratoonOperation', 
    label:'Ratooning Operation', 
    type:'select',
    options:[
      'Trash Mulching',
      'Trash Burning',
      'Trash Clearing',
      'Stubble Shaving',
      'Others'
    ]
  },

  { 
    id:'method', 
    label:'Method Used', 
    type:'select',
    options:[
      'Manual',
      'Mechanical',
      'Manual + Mechanical',
      'Others'
    ]
  },

  { 
    id:'areaCovered', 
    label:'Area Covered (ha)', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'workers', 
    label:'Number of Workers', 
    type:'number'
  },

  { 
    id:'equipment', 
    label:'Equipment Used', 
    type:'select',
    options:[
      'Trash Shredder',
      'Mower',
      'Tractor',
      'Manual Tools',
      'Others'
    ]
  },

  { 
    id:'laborCost', 
    label:'Labor Cost', 
    type:'number',
    step:'0.01',
    enhanced: true
  },

  { 
    id:'fuelCost', 
    label:'Fuel Cost', 
    type:'number',
    step:'0.01'
  },

  { 
    id:'totalCost', 
    label:'Total Cost', 
    type:'number',
    step:'0.01'
  },


],

 "Vehicle Updates": [
    {id:'startDate', label:'Start Date', type:'date'},
    {id:'endDate', label:'End Date', type:'date'},
    {id:'activeDrivers', label:'Active Drivers', type:'number'},
    {id:'returningDrivers', label:'Returning Drivers', type:'number'},
    {id:'boxes', label:'Boxes Transported', type:'number'},
    {id:'weight', label:'Total Cane Weight', type:'number'},
    {id:'fuelCost', label:'Fuel Cost', type:'fuel'}, 
    {id:'laborCost', label:'Labor Cost', type:'number'},
    {id:'totalCost', label:'Total Cost', type:'number', readonly: true},
    {id:'vehicleType', label:'Vehicle Type', type:'select', options:['Truck', 'Tractor', 'Other']},
    {id:'driverRent', label:'Is Driver/Worker Rented?', type:'select', options:['Yes','No','Other']},
  ]
};

// Store current editing record ID (if any)
let editingRecordId = null;

onAuthStateChanged(auth,async user=>{
  if(!user)return location.href='../Common/farmers_login.html'
  uid=user.uid
  
  // Load fields FIRST before checking for edit mode
  // This ensures fields are available when editing
  if (document.readyState === 'loading') {
    await new Promise(resolve => {
      document.addEventListener('DOMContentLoaded', resolve);
    });
  }
  
  // Ensure buttons are attached (in case they weren't attached earlier)
  attachButtonHandlers();
  
  // Load fields immediately
  await loadFields();
  
  // Check if we're editing an existing record (after fields are loaded)
  const params = new URLSearchParams(window.location.search);
  const editRecordId = params.get('editRecordId');
  
  if (editRecordId) {
    editingRecordId = editRecordId;
    console.log('📝 Edit mode activated. Record ID:', editingRecordId);
    // Load the record and populate the form
    await loadRecordForEdit(editRecordId);
  } else {
    // Ensure editingRecordId is null when not editing
    editingRecordId = null;
    console.log('📝 New record mode');
  }
})

// Function to attach button handlers (can be called multiple times safely)
function attachButtonHandlers() {
  // Handle partial save (Save Record button)
  const savePartialBtn = document.getElementById('savePartialBtn');
  if (savePartialBtn && !savePartialBtn.dataset.handlerAttached) {
    savePartialBtn.dataset.handlerAttached = 'true';
    savePartialBtn.onclick = async (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('🔄 Save Record button clicked (partial save)');
      try {
        await handleSubmit(false); // false = partial save
      } catch (error) {
        console.error('❌ Error in handleSubmit (partial):', error);
        showNotification('error', 'Save Failed', 'An error occurred while saving. Please try again.');
      }
    };
    console.log('✅ Save Record button handler attached');
  } else if (!savePartialBtn) {
    console.warn('⚠️ Save Record button not found yet');
  }

  // Handle complete save (Done Record button)
  const submitBtn = document.getElementById('submitBtn');
  if (submitBtn && !submitBtn.dataset.handlerAttached) {
    submitBtn.dataset.handlerAttached = 'true';
    submitBtn.onclick = async (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('🔄 Done Record button clicked (complete save)');
      try {
        await handleSubmit(true); // true = done save
      } catch (error) {
        console.error('❌ Error in handleSubmit (done):', error);
        showNotification('error', 'Save Failed', 'An error occurred while saving. Please try again.');
      }
    };
    console.log('✅ Done Record button handler attached');
  } else if (!submitBtn) {
    console.warn('⚠️ Done Record button not found yet');
  }
}

// Load record data for editing
async function loadRecordForEdit(recordId) {
  try {
    showLoading(true);
    console.log('🔄 Loading record for edit:', recordId);
    
    // Set flag to prevent form clearing during edit mode
    window._isLoadingEditRecord = true;
    
    const { getDoc, doc, getDocs, collection } = await import('https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js');
    const recordRef = doc(db, 'records', recordId);
    const recordSnap = await getDoc(recordRef);
    
    if (!recordSnap.exists()) {
      window._isLoadingEditRecord = false;
      showLoading(false);
      alert('Record not found. It may have been deleted.');
      window.location.href = 'Input-Records.html';
      return;
    }
    
    const recordData = recordSnap.data();
    console.log('✅ Record loaded:', recordData);
    
    // Check if record is editable (only "Not Done Yet" records can be edited)
    const recordStatus = recordData.recordStatus || 'Done';
    if (recordStatus === 'Done') {
      window._isLoadingEditRecord = false;
      showLoading(false);
      alert('This record is already completed and cannot be edited.');
      window.location.href = 'Input-Records.html';
      return;
    }
    
    // Load subcollections
    const [boughtItemsSnap, vehicleUpdatesSnap] = await Promise.all([
      getDocs(collection(db, 'records', recordId, 'bought_items')).catch(() => ({ docs: [] })),
      getDocs(collection(db, 'records', recordId, 'vehicle_updates')).catch(() => ({ docs: [] }))
    ]);
    
    const boughtItems = boughtItemsSnap.docs.map(d => d.data());
    const vehicleUpdates = vehicleUpdatesSnap.docs.length > 0 ? vehicleUpdatesSnap.docs[0].data() : null;
    
    // Store record data globally for population after form renders
    window._editingRecordData = {
      recordData: recordData.data || {},
      boughtItems: boughtItems,
      vehicleUpdates: vehicleUpdates
    };
    
    // Step 1: Ensure fields are loaded (they should already be loaded, but double-check)
    console.log('⏳ Checking if fields are loaded...');
    if (!fieldSelect || fieldSelect.options.length <= 1) {
      console.log('⏳ Fields not loaded yet, waiting...');
      await new Promise((resolve) => {
        let attempts = 0;
        const maxAttempts = 30; // 3 seconds max (30 * 100ms)
        const checkFieldsLoaded = () => {
          attempts++;
          if (fieldSelect && fieldSelect.options.length > 1) { // More than just "Select" option
            console.log('✅ Fields loaded');
            resolve();
          } else if (attempts >= maxAttempts) {
            console.warn('⚠️ Fields loading timeout, proceeding anyway...');
            resolve(); // Resolve anyway to continue
  } else {
            setTimeout(checkFieldsLoaded, 100);
          }
        };
        checkFieldsLoaded();
      });
    } else {
      console.log('✅ Fields already loaded');
    }
    
    // Set field value
    if (recordData.fieldId && fieldSelect) {
      console.log('📝 Setting field:', recordData.fieldId);
      fieldSelect.value = recordData.fieldId;
      // Update custom select display
      const fieldSelectInstance = customSelectInstances.get('fieldSelect');
      if (fieldSelectInstance) {
        fieldSelectInstance.updateSelectedLabel();
      }
      
      // Manually show operations in edit mode (don't trigger change event which might clear things)
      console.log('🔄 Manually showing operations for edit mode');
      
      // Populate operations manually
      const allOperations = [
        'Pre-Planting',
        'Planting',
        'Post-Planting',
        'Detrashing',
        'Harvesting',
        'Replanting',
        'Ratooning'
      ];
      operationSelect.innerHTML = '<option value="">Select</option>' +
        allOperations.map(op => `<option value="${op}">${op}</option>`).join('');
      
      // Show operation wrap
      operationWrap.classList.remove('hidden');
      
      // Re-initialize custom select after updating options
      const operationSelectInstance = customSelectInstances.get('operationSelect');
      if (operationSelectInstance) {
        operationSelectInstance.renderOptions();
      } else {
        // Initialize if it doesn't exist
        initializeCustomSelect(operationSelect);
        const newInstance = customSelectInstances.get('operationSelect');
        if (newInstance) {
          newInstance.renderOptions();
        }
      }
      
      // Wait a moment for operations to be ready
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Now set the operation value AFTER operations are populated
      if (recordData.operation && operationSelect) {
        console.log('📝 Setting operation:', recordData.operation);
        operationSelect.value = recordData.operation;
        
        // Update custom select display
        const operationSelectInstance2 = customSelectInstances.get('operationSelect');
        if (operationSelectInstance2) {
          operationSelectInstance2.updateSelectedLabel();
        } else {
          // If instance doesn't exist, try to update manually
          const operationSelectWrapper = document.querySelector('[data-select-id="operationSelect"]');
          if (operationSelectWrapper) {
            const valueEl = operationSelectWrapper.querySelector('.custom-select-value');
            if (valueEl) {
              const option = operationSelect.querySelector(`option[value="${recordData.operation}"]`);
              valueEl.textContent = option ? option.textContent : recordData.operation;
            }
          }
        }
        
        console.log('✅ Operation set to:', operationSelect.value);
        
        // Manually trigger task type population (don't use change event in edit mode)
        console.log('🔄 Manually showing task types for edit mode');
        const operation = recordData.operation;
        const tasks = operationToTasks[operation] || [];
        
        if (tasks.length > 0) {
          taskTypeWrap.classList.remove('hidden');
          taskType.innerHTML = '<option value="">Select</option>' +
            tasks.map(t => `<option value="${t}">${t}</option>`).join('');
          
          // Re-initialize custom select after updating options
          const taskTypeInstance = customSelectInstances.get('taskType');
          if (taskTypeInstance) {
            taskTypeInstance.renderOptions();
          }
          
          // Wait for task types to be populated
          await new Promise((resolve) => {
            let attempts = 0;
            const maxAttempts = 30;
            const check = () => {
              attempts++;
              if (taskType && taskType.options.length > 1) {
                console.log('✅ Task types populated');
                resolve();
              } else if (attempts >= maxAttempts) {
                console.warn('⚠️ Task types timeout, proceeding anyway...');
                resolve();
              } else {
                setTimeout(check, 50);
              }
            };
            check();
          });
        }
      }
    }
    
    // Step 3: Set task type value and wait for form to render
    if (recordData.taskType && taskType) {
      console.log('📝 Setting task type:', recordData.taskType);
      
      // Map display name to taskFieldMap key (same logic as in taskType.onchange)
      const taskDisplayName = recordData.taskType;
      
      // Safety check: ensure taskNameAliases exists
      if (typeof taskNameAliases === 'undefined' || !taskNameAliases) {
        console.error('❌ taskNameAliases is not defined');
        showLoading(false);
        window._isLoadingEditRecord = false;
        alert('Error: taskNameAliases not found. Please refresh the page.');
        return;
      }
      
      const taskKey = taskNameAliases[taskDisplayName] || taskDisplayName;
      console.log('📝 Task key for form rendering:', taskKey);
      
      // Safety check: ensure taskKey is valid
      if (!taskKey || typeof taskKey !== 'string') {
        console.error('❌ Invalid taskKey:', taskKey, 'from taskDisplayName:', taskDisplayName);
        showLoading(false);
        window._isLoadingEditRecord = false;
        alert('Error: Invalid task type. Please refresh the page.');
        return;
      }
      
      // Set the value
      taskType.value = recordData.taskType;
      
      // Update custom select display
      const taskTypeSelectInstance = customSelectInstances.get('taskType');
      if (taskTypeSelectInstance) {
        taskTypeSelectInstance.updateSelectedLabel();
      }
      
      // Manually render the form (don't rely on change event in edit mode)
      console.log('🔄 Rendering form for task:', taskKey);
      renderForm(taskKey);
      
      // Show optional sections
      const boughtItemsSection = document.getElementById('boughtItemsSection');
      const vehicleUpdatesSection = document.getElementById('vehicleUpdatesSection');
      if (boughtItemsSection) boughtItemsSection.classList.remove('hidden');
      if (vehicleUpdatesSection) vehicleUpdatesSection.classList.remove('hidden');
      
      // Wait for form to render (check if dynamicForm has content) with timeout
      console.log('⏳ Waiting for form to render...');
      await new Promise((resolve) => {
        let attempts = 0;
        const maxAttempts = 30; // 3 seconds max
        const checkFormRendered = () => {
          attempts++;
          const dynamicForm = document.getElementById('dynamicForm');
          if (dynamicForm && !dynamicForm.classList.contains('hidden') && dynamicForm.children.length > 0) {
            console.log('✅ Form rendered with', dynamicForm.children.length, 'children');
            resolve();
          } else if (attempts >= maxAttempts) {
            console.warn('⚠️ Form rendering timeout after', attempts, 'attempts. Form state:', {
              exists: !!dynamicForm,
              hidden: dynamicForm?.classList.contains('hidden'),
              children: dynamicForm?.children.length || 0
            });
            resolve(); // Resolve anyway to continue
          } else {
            setTimeout(checkFormRendered, 100);
          }
        };
        checkFormRendered();
      });
      
      // Additional wait to ensure all custom selects are initialized
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Re-initialize any custom selects that might not have been initialized
      const dynamicForm = document.getElementById('dynamicForm');
      if (dynamicForm) {
        const allSelects = dynamicForm.querySelectorAll('select.custom-native-hidden');
        console.log('🔍 Found', allSelects.length, 'selects in form');
        allSelects.forEach(select => {
          if (!customSelectInstances.has(select.id)) {
            console.log('🔧 Initializing custom select:', select.id);
            initializeCustomSelect(select);
          }
        });
      }
    }
    
    // Step 4: Now populate all data fields
    if (window._editingRecordData.recordData) {
      const data = window._editingRecordData.recordData;
      
      // Populate fields in order, handling special cases
      Object.keys(data).forEach(key => {
        const input = document.getElementById(key);
        if (!input) return;
        
        const value = data[key];
        if (value === null || value === undefined) return;
        
        if (input.type === 'date') {
          // Convert Firestore Timestamp or Date to YYYY-MM-DD format
          let dateValue = value;
          if (dateValue && dateValue.toDate && typeof dateValue.toDate === 'function') {
            dateValue = dateValue.toDate();
          }
          if (dateValue instanceof Date) {
            const year = dateValue.getFullYear();
            const month = String(dateValue.getMonth() + 1).padStart(2, '0');
            const day = String(dateValue.getDate()).padStart(2, '0');
            input.value = `${year}-${month}-${day}`;
          } else if (typeof dateValue === 'string') {
            // Handle string dates (might be in YYYY-MM-DD format already)
            input.value = dateValue;
          }
        } else if (input.tagName === 'SELECT' || input.classList.contains('custom-native-hidden')) {
          // Handle select fields (including custom selects)
          const selectValue = String(value || '');
          
          // Set native select value first
          if (input.tagName === 'SELECT') {
            input.value = selectValue;
          }
          
          // Update custom select display
          const customSelectInstance = customSelectInstances.get(key);
          if (customSelectInstance) {
            customSelectInstance.updateSelectedLabel();
          } else {
            // Try to find and update custom select wrapper manually
            const customSelectWrapper = document.querySelector(`[data-select-id="${key}"]`);
            if (customSelectWrapper) {
              const valueEl = customSelectWrapper.querySelector('.custom-select-value');
              if (valueEl && input.tagName === 'SELECT') {
                const option = input.querySelector(`option[value="${selectValue}"]`);
                valueEl.textContent = option ? option.textContent : (selectValue || 'Select');
              }
            }
          }
          
          // Handle "Others" option - show _other input if value is "Others" or "Other"
          if (selectValue && (selectValue === 'Others' || selectValue === 'Other')) {
            const otherInput = document.getElementById(key + '_other');
            if (otherInput) {
              otherInput.classList.remove('hidden');
              otherInput.required = true;
              // Check if there's a custom value stored
              if (data[key + '_other']) {
                otherInput.value = data[key + '_other'];
              }
            }
          }
          
          // CRITICAL: For equipment/method/cleaningMethod fields, don't trigger change event in edit mode
          // We'll handle truckRented manually after all fields are populated
          // For other select fields, trigger change event
          if (key !== 'equipment' && key !== 'method' && key !== 'cleaningMethod') {
            input.dispatchEvent(new Event('change', { bubbles: true }));
          } else {
            // For equipment fields, update custom select display manually
            const customSelectInstance = customSelectInstances.get(key);
            if (customSelectInstance) {
              customSelectInstance.updateSelectedLabel();
            }
          }
        } else if (input.type === 'number') {
          input.value = value || 0;
          // Trigger input event for number fields to update calculations
          input.dispatchEvent(new Event('input', { bubbles: true }));
        } else if (input.tagName === 'TEXTAREA') {
          input.value = value || '';
        } else {
          input.value = value || '';
        }
      });
      
      // Handle special fields that might need additional processing
      // Enhanced labor cost fields
      if (data.laborRatePerDay !== undefined) {
        const laborRateInput = document.getElementById('laborRatePerDay');
        if (laborRateInput) laborRateInput.value = data.laborRatePerDay || 0;
      }
      if (data.laborWorkers !== undefined) {
        const laborWorkersInput = document.getElementById('laborWorkers');
        if (laborWorkersInput) laborWorkersInput.value = data.laborWorkers || 0;
      }
      if (data.laborWorkingDays !== undefined) {
        const laborWorkingDaysInput = document.getElementById('laborWorkingDays');
        if (laborWorkingDaysInput) laborWorkingDaysInput.value = data.laborWorkingDays || 0;
      }
      
      // CRITICAL: Handle truckRented and rentCost for Mechanical and Animal-Drawn equipment
      // Check DATA first to see if Mechanical or Animal-Drawn was selected (not field values, as fields might not be populated yet)
      const hasMechanical = (data.equipment && (data.equipment === 'Mechanical' || data.equipment.includes('Mechanical'))) ||
                           (data.method && (data.method === 'Mechanical' || data.method.includes('Mechanical'))) ||
                           (data.cleaningMethod && (data.cleaningMethod === 'Mechanical' || data.cleaningMethod.includes('Mechanical')));
      
      const hasAnimal = (data.equipment && (data.equipment === 'Animal-Drawn' || data.equipment.includes('Animal-Drawn') || (data.equipment.includes('Animal') && !data.equipment.includes('Mechanical')))) ||
                        (data.method && (data.method === 'Animal-Drawn' || data.method.includes('Animal-Drawn') || (data.method.includes('Animal') && !data.method.includes('Mechanical')))) ||
                        (data.cleaningMethod && (data.cleaningMethod === 'Animal-Drawn' || data.cleaningMethod.includes('Animal-Drawn') || (data.cleaningMethod.includes('Animal') && !data.cleaningMethod.includes('Mechanical'))));
      
      // Determine which field ID triggers truckRented/animalRented
      let methodFieldId = null;
      let isMechanicalSelection = false;
      let isAnimalSelection = false;
      
      if (data.equipment && (data.equipment === 'Mechanical' || data.equipment.includes('Mechanical'))) {
        methodFieldId = 'equipment';
        isMechanicalSelection = true;
      } else if (data.equipment && (data.equipment === 'Animal-Drawn' || data.equipment.includes('Animal-Drawn') || (data.equipment.includes('Animal') && !data.equipment.includes('Mechanical')))) {
        methodFieldId = 'equipment';
        isAnimalSelection = true;
      } else if (data.method && (data.method === 'Mechanical' || data.method.includes('Mechanical'))) {
        methodFieldId = 'method';
        isMechanicalSelection = true;
      } else if (data.method && (data.method === 'Animal-Drawn' || data.method.includes('Animal-Drawn') || (data.method.includes('Animal') && !data.method.includes('Mechanical')))) {
        methodFieldId = 'method';
        isAnimalSelection = true;
      } else if (data.cleaningMethod && (data.cleaningMethod === 'Mechanical' || data.cleaningMethod.includes('Mechanical'))) {
        methodFieldId = 'cleaningMethod';
        isMechanicalSelection = true;
      } else if (data.cleaningMethod && (data.cleaningMethod === 'Animal-Drawn' || data.cleaningMethod.includes('Animal-Drawn') || (data.cleaningMethod.includes('Animal') && !data.cleaningMethod.includes('Mechanical')))) {
        methodFieldId = 'cleaningMethod';
        isAnimalSelection = true;
      }
      
      console.log('🔧 Checking for Mechanical/Animal in data:', { 
        equipment: data.equipment, 
        method: data.method, 
        cleaningMethod: data.cleaningMethod,
        methodFieldId,
        hasMechanical,
        hasAnimal,
        isMechanicalSelection,
        isAnimalSelection,
        truckRented: data.truckRented,
        rentCost: data.rentCost
      });
      
      // If Mechanical or Animal-Drawn is selected in data, create truckRented container
      if ((hasMechanical || hasAnimal) && methodFieldId) {
        console.log('🔧 Mechanical/Animal detected in data, creating truckRented container...');
        
        // Determine label based on selection
        const rentLabel = isMechanicalSelection ? 'Is the truck rented?' : 'Is the animal/equipment rented?';
        
        // Wait a bit for form to render, then create containers
        setTimeout(() => {
          const methodField = document.getElementById(methodFieldId);
          const truckRentedContainer = document.getElementById('truckRentedContainer');
          
          if (!truckRentedContainer && methodField) {
            const currentFieldDiv = methodField.closest('.mb-4');
            if (currentFieldDiv) {
            const newDiv = document.createElement('div');
            newDiv.id = 'truckRentedContainer';
            newDiv.className = 'mb-4';
            newDiv.innerHTML = `
              <label class="text-xs font-medium">${rentLabel} <span class="text-red-500">*</span></label>
              <select id="truckRented" class="w-full border rounded px-3 py-2" required>
                <option value="">Select</option>
                <option value="Yes">Yes</option>
                <option value="No">No</option>
              </select>
            `;
            currentFieldDiv.parentNode.insertBefore(newDiv, currentFieldDiv.nextSibling);
            
            // Initialize custom select for truckRented
            const truckRentedSelect = document.getElementById('truckRented');
            if (truckRentedSelect) {
              initializeCustomSelect(truckRentedSelect);
              
              // Set value if saved
              if (data.truckRented) {
                truckRentedSelect.value = data.truckRented;
                const truckRentedInstance = customSelectInstances.get('truckRented');
                if (truckRentedInstance) {
                  truckRentedInstance.updateSelectedLabel();
                }
                
                // If "Yes", create rentCost container
                if (data.truckRented === 'Yes') {
                  const rentCostContainer = document.getElementById('rentCostContainer');
                  if (!rentCostContainer) {
                    const truckRentedDiv = document.getElementById('truckRentedContainer');
                    if (truckRentedDiv) {
                      const rentCostDiv = document.createElement('div');
                      rentCostDiv.id = 'rentCostContainer';
                      rentCostDiv.className = 'mb-4';
                      rentCostDiv.innerHTML = `
                        <label class="text-xs font-medium">Rent Cost <span class="text-red-500">*</span></label>
                        <input type="number" step="0.01" id="rentCost" class="w-full border rounded px-3 py-2" required />
                      `;
                      truckRentedDiv.parentNode.insertBefore(rentCostDiv, truckRentedDiv.nextSibling);
                      
                      // Populate rentCost if saved
                      if (data.rentCost !== undefined) {
                        const rentCostInput = document.getElementById('rentCost');
                        if (rentCostInput) {
                          rentCostInput.value = data.rentCost || 0;
                        }
                      }
                      
                      // Add event listener for rentCost to update total cost
                      const rentCostInput = document.getElementById('rentCost');
                      if (rentCostInput) {
                        const updateTotalCostFn = window.updateTotalCost || (typeof updateTotalCost !== 'undefined' ? updateTotalCost : null);
                        if (updateTotalCostFn && typeof updateTotalCostFn === 'function') {
                          rentCostInput.addEventListener('input', updateTotalCostFn);
                          rentCostInput.addEventListener('change', updateTotalCostFn);
                        }
                      }
                    }
                  } else {
                    // Container exists, just show it and populate
                    const rentCostContainerEl = document.getElementById('rentCostContainer');
                    if (rentCostContainerEl) {
                      rentCostContainerEl.classList.remove('hidden');
                      const rentCostInput = document.getElementById('rentCost');
                      if (rentCostInput) {
                        rentCostInput.value = data.rentCost || 0;
                        rentCostInput.required = true;
                      }
                    }
                  }
                }
              }
              
              // Add handler for truckRented change to show/hide Rent Cost
              if (!truckRentedSelect.dataset.rentHandlerAttached) {
                truckRentedSelect.dataset.rentHandlerAttached = 'true';
                truckRentedSelect.addEventListener('change', function() {
                  const rentCostContainerEl = document.getElementById('rentCostContainer');
                  
                  if (this.value === 'Yes') {
                    if (!rentCostContainerEl) {
                      const truckRentedDiv = document.getElementById('truckRentedContainer');
                      if (truckRentedDiv) {
                        const rentCostDiv = document.createElement('div');
                        rentCostDiv.id = 'rentCostContainer';
                        rentCostDiv.className = 'mb-4';
                        rentCostDiv.innerHTML = `
                          <label class="text-xs font-medium">Rent Cost <span class="text-red-500">*</span></label>
                          <input type="number" step="0.01" id="rentCost" class="w-full border rounded px-3 py-2" required />
                        `;
                        truckRentedDiv.parentNode.insertBefore(rentCostDiv, truckRentedDiv.nextSibling);
                        
                        const rentCostInput = document.getElementById('rentCost');
                        if (rentCostInput) {
                          const updateTotalCostFn = window.updateTotalCost || (typeof updateTotalCost !== 'undefined' ? updateTotalCost : null);
                          if (updateTotalCostFn && typeof updateTotalCostFn === 'function') {
                            rentCostInput.addEventListener('input', updateTotalCostFn);
                            rentCostInput.addEventListener('change', updateTotalCostFn);
                          }
                        }
                      }
                    } else {
                      rentCostContainerEl.classList.remove('hidden');
                      const rentCostInput = document.getElementById('rentCost');
                      if (rentCostInput) rentCostInput.required = true;
                    }
                  } else {
                    if (rentCostContainerEl) {
                      rentCostContainerEl.classList.add('hidden');
                      const rentCostInput = document.getElementById('rentCost');
                      if (rentCostInput) {
                        rentCostInput.required = false;
                        rentCostInput.value = '';
                      }
                      const updateTotalCostFn = window.updateTotalCost || (typeof updateTotalCost !== 'undefined' ? updateTotalCost : null);
                      if (updateTotalCostFn && typeof updateTotalCostFn === 'function') {
                        updateTotalCostFn();
                      }
                    }
                  }
                });
              }
            }
          }
          } else if (truckRentedContainer) {
            // Container exists, update label and show it
            const labelEl = truckRentedContainer.querySelector('label');
            if (labelEl) {
              labelEl.innerHTML = `${rentLabel} <span class="text-red-500">*</span>`;
            }
            truckRentedContainer.classList.remove('hidden');
            const truckRentedSelect = document.getElementById('truckRented');
            if (truckRentedSelect) {
              if (data.truckRented) {
                truckRentedSelect.value = data.truckRented;
                const truckRentedInstance = customSelectInstances.get('truckRented');
                if (truckRentedInstance) {
                  truckRentedInstance.updateSelectedLabel();
                }
                
                // If "Yes", show and populate rentCost
                if (data.truckRented === 'Yes') {
                  const rentCostContainerEl = document.getElementById('rentCostContainer');
                  if (rentCostContainerEl) {
                    rentCostContainerEl.classList.remove('hidden');
                    const rentCostInput = document.getElementById('rentCost');
                    if (rentCostInput) {
                      rentCostInput.value = data.rentCost || 0;
                      rentCostInput.required = true;
                    }
                  }
                }
              }
            }
          }
        }, 100); // Small delay to ensure form is rendered
      }
      
      // Trigger total cost calculation
      const updateTotalCostFn = window.updateTotalCost;
      if (updateTotalCostFn && typeof updateTotalCostFn === 'function') {
        setTimeout(() => updateTotalCostFn(), 300);
      }
    }
    
    // Step 5: Populate bought items
    if (window._editingRecordData.boughtItems && window._editingRecordData.boughtItems.length > 0) {
      // Show bought items section
      const boughtItemsSection = document.getElementById('boughtItemsSection');
      const boughtItemsContent = document.getElementById('boughtItemsContent');
      const toggleBoughtItems = document.getElementById('toggleBoughtItems');
      
      if (boughtItemsSection) boughtItemsSection.classList.remove('hidden');
      if (boughtItemsContent) boughtItemsContent.classList.remove('hidden');
      if (toggleBoughtItems) toggleBoughtItems.textContent = 'Hide Section';
      
      // Populate bought items by clicking add button for each item
      const boughtItemsList = document.getElementById('boughtItemsList');
      const addBoughtItemBtn = document.getElementById('addBoughtItemBtn');
      
      if (boughtItemsList && addBoughtItemBtn) {
        boughtItemsList.innerHTML = '';
        
        // Add each bought item one by one
        for (const item of window._editingRecordData.boughtItems) {
          // Click add button to create new item
          addBoughtItemBtn.click();
          
          // Wait a bit for the item to be added to DOM
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // Find the last added item and populate it
          const itemDivs = boughtItemsList.querySelectorAll('.border.rounded');
          const itemDiv = itemDivs[itemDivs.length - 1];
          
          if (itemDiv) {
            const nameInput = itemDiv.querySelector('.bought-item-name');
            const qtyInput = itemDiv.querySelector('.bought-item-qty');
            // Find the unit select - it's a custom select, so find the native select
            const unitSelect = itemDiv.querySelector('select.custom-native-hidden');
            const priceInput = itemDiv.querySelector('.bought-item-price');
            const totalInput = itemDiv.querySelector('.bought-item-total');
            const supplierInput = itemDiv.querySelector('.bought-item-supplier');
            const notesInput = itemDiv.querySelector('.bought-item-notes');
            
            if (nameInput) nameInput.value = item.itemName || '';
            if (qtyInput) qtyInput.value = item.quantity || 0;
            if (unitSelect) {
              unitSelect.value = item.unit || '';
              // Update custom select display
              const unitSelectInstance = customSelectInstances.get(unitSelect.id);
              if (unitSelectInstance) {
                unitSelectInstance.updateSelectedLabel();
              } else {
                // Try to update manually if instance not found
                const customSelectWrapper = document.querySelector(`[data-select-id="${unitSelect.id}"]`);
                if (customSelectWrapper) {
                  const valueEl = customSelectWrapper.querySelector('.custom-select-value');
                  if (valueEl && unitSelect.tagName === 'SELECT') {
                    const option = unitSelect.querySelector(`option[value="${item.unit}"]`);
                    valueEl.textContent = option ? option.textContent : (item.unit || 'Select');
                  }
                }
              }
            }
            if (priceInput) priceInput.value = item.price || 0;
            if (totalInput) totalInput.value = item.total || 0;
            if (supplierInput) supplierInput.value = item.supplier || '';
            if (notesInput) notesInput.value = item.notes || '';
            
            // Trigger total calculation
            if (qtyInput && priceInput) {
              qtyInput.dispatchEvent(new Event('input', { bubbles: true }));
              priceInput.dispatchEvent(new Event('input', { bubbles: true }));
            }
          }
        }
      }
    }
    
    // Step 6: Populate vehicle updates
    if (window._editingRecordData.vehicleUpdates) {
      const vehicleUpdates = window._editingRecordData.vehicleUpdates;
      const vehicleUpdatesSection = document.getElementById('vehicleUpdatesSection');
      const vehicleUpdatesContent = document.getElementById('vehicleUpdatesContent');
      const toggleVehicleUpdates = document.getElementById('toggleVehicleUpdates');
      
      if (vehicleUpdatesSection) vehicleUpdatesSection.classList.remove('hidden');
      if (vehicleUpdatesContent) vehicleUpdatesContent.classList.remove('hidden');
      if (toggleVehicleUpdates) toggleVehicleUpdates.textContent = 'Hide Section';
      
      // Populate vehicle update fields
      const vehicleTypeInput = document.getElementById('vehicleType');
      const tripsBoxesInput = document.getElementById('tripsBoxes');
      const vehicleFuelCostInput = document.getElementById('vehicleFuelCost');
      const vehicleLaborCostInput = document.getElementById('vehicleLaborCost');
      const vehicleTotalCostInput = document.getElementById('vehicleTotalCost');
      const vehicleRouteInput = document.getElementById('vehicleRoute');
      
      if (vehicleTypeInput) {
        vehicleTypeInput.value = vehicleUpdates.vehicleType || '';
        // Update custom select if it exists
        const vehicleTypeSelectInstance = customSelectInstances.get('vehicleType');
        if (vehicleTypeSelectInstance) {
          vehicleTypeSelectInstance.updateSelectedLabel();
        }
      }
      if (tripsBoxesInput) tripsBoxesInput.value = vehicleUpdates.tripsBoxes || 0;
      if (vehicleFuelCostInput) vehicleFuelCostInput.value = vehicleUpdates.fuelCost || 0;
      if (vehicleLaborCostInput) vehicleLaborCostInput.value = vehicleUpdates.laborCost || 0;
      if (vehicleTotalCostInput) vehicleTotalCostInput.value = vehicleUpdates.totalCost || 0;
      if (vehicleRouteInput) vehicleRouteInput.value = vehicleUpdates.route || '';
      
      // Trigger total cost calculation
      if (vehicleFuelCostInput) vehicleFuelCostInput.dispatchEvent(new Event('input'));
      if (vehicleLaborCostInput) vehicleLaborCostInput.dispatchEvent(new Event('input'));
    }
    
    console.log('✅ Record edit form loaded successfully');
    
    // Clear the loading flag AFTER everything is populated
    window._isLoadingEditRecord = false;
    
    showLoading(false);
    showNotification('info', 'Editing Record', 'You are editing a partial record. Complete it by adding an End Date and clicking "Done Record".');
    
    // Clean up stored data after a delay
    setTimeout(() => {
      delete window._editingRecordData;
    }, 5000);
    
  } catch (error) {
    console.error('❌ Error loading record for edit:', error);
    window._isLoadingEditRecord = false;
    showLoading(false);
    alert('Failed to load record for editing. Please try again.');
    // Don't redirect immediately, let user see the error
    setTimeout(() => {
      if (!window._editingRecordData) {
        window.location.href = 'Input-Records.html';
      }
    }, 2000);
  }
}

// Store current field area for Seed Rate calculation
let currentFieldArea = null;

// Cache for done tasks to avoid repeated queries
let doneTasksCache = new Map(); // Key: `${fieldId}_${operation}_${taskType}`, Value: boolean

/**
 * Check if a task is done (exists in Growth Tracker via records collection)
 * Growth Tracker = Final Authority: If a task appears in Growth Tracker, it is considered Done
 * @param {string} fieldId - Field ID
 * @param {string} operation - Field Operation
 * @param {string} taskType - Task Type
 * @returns {Promise<boolean>} True if task is done
 */
async function isTaskDone(fieldId, operation, taskType) {
  if (!fieldId || !operation || !taskType) {
    return false;
  }
  
  // Check cache first
  const cacheKey = `${fieldId}_${operation}_${taskType}`;
  if (doneTasksCache.has(cacheKey)) {
    return doneTasksCache.get(cacheKey);
  }
  
  try {
    const { query, collection, where, getDocs } = await import('https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js');
    
    // Query records collection for Done records matching this field, operation, and task type
    const recordsQuery = query(
      collection(db, 'records'),
      where('fieldId', '==', fieldId),
      where('operation', '==', operation),
      where('taskType', '==', taskType),
      where('recordStatus', '==', 'Done')
    );
    
    const snapshot = await getDocs(recordsQuery);
    const isDone = !snapshot.empty;
    
    // Cache the result
    doneTasksCache.set(cacheKey, isDone);
    
    return isDone;
  } catch (error) {
    console.error('Error checking if task is done:', error);
    // On error, assume not done to be safe (don't hide tasks)
    return false;
  }
}

/**
 * Check which tasks are done for a given field and operation
 * Returns a Set of done task types for efficient lookup
 * @param {string} fieldId - Field ID
 * @param {string} operation - Field Operation
 * @param {Array<string>} taskTypes - Array of task types to check
 * @returns {Promise<Set<string>>} Set of done task types
 */
async function getDoneTasks(fieldId, operation, taskTypes) {
  if (!fieldId || !operation || !taskTypes || taskTypes.length === 0) {
    return new Set();
  }
  
  const doneTasks = new Set();
  
  // Check all tasks in parallel for better performance
  const checks = taskTypes.map(async (taskType) => {
    const isDone = await isTaskDone(fieldId, operation, taskType);
    if (isDone) {
      doneTasks.add(taskType);
    }
  });
  
  await Promise.all(checks);
  
  return doneTasks;
}

/**
 * Clear done tasks cache (call when field changes or after undo)
 */
function clearDoneTasksCache() {
  doneTasksCache.clear();
}

// Helper function to auto-select and progress when only one option exists
function autoSelectAndProgress(selectElement, selectId, nextElement = null) {
  if (!selectElement) return false;
  
  // Get all options excluding the empty "Select" option
  const options = Array.from(selectElement.options).filter(opt => opt.value !== '');
  
  // If only one option exists, auto-select it
  if (options.length === 1) {
    selectElement.value = options[0].value;
    
    // Update custom select display if it exists
    const customSelectInstance = customSelectInstances.get(selectId);
    if (customSelectInstance) {
      customSelectInstance.updateSelectedLabel();
    }
    
    // Trigger change event to activate handlers
    selectElement.dispatchEvent(new Event('change', { bubbles: true }));
    
    // Move focus to next element if provided
    if (nextElement) {
      setTimeout(() => {
        if (nextElement instanceof HTMLElement) {
          nextElement.focus();
        } else if (typeof nextElement === 'string') {
          const nextEl = document.getElementById(nextElement);
          if (nextEl) {
            // For custom selects, focus the trigger button
            const customSelectWrapper = nextEl.closest('.custom-select');
            if (customSelectWrapper) {
              const trigger = customSelectWrapper.querySelector('.custom-select-trigger');
              if (trigger) trigger.focus();
            } else {
              nextEl.focus();
            }
          }
        }
      }, 100);
    }
    
    return true;
  }
  
  return false;
}

async function loadFields(){
  try {
    // Show loading state in dropdown
    const fieldSelectInstance = customSelectInstances.get('fieldSelect');
    if (fieldSelectInstance) {
      const trigger = document.querySelector('[data-select-id="fieldSelect"] .custom-select-trigger .custom-select-value');
      if (trigger) trigger.textContent = 'Loading fields...';
    }
    
    // Load fields from Firestore
    const q = query(collection(db,'fields'), where('userId','==',uid));
    const snap = await getDocs(q);

    // Add default "Select" option first
    fieldSelect.innerHTML = '<option value="">Select</option>' + 
      snap.docs.map(d => `<option value="${d.id}">${d.data().field_name || d.data().fieldName || 'Unnamed Field'}</option>`).join('');
    
    // Immediately render options in custom select (don't wait for MutationObserver)
    if (fieldSelectInstance) {
      fieldSelectInstance.renderOptions();
    } else {
      // If instance doesn't exist yet, initialize it
      const fieldSelectEl = document.getElementById('fieldSelect');
      if (fieldSelectEl) {
        initializeCustomSelect(fieldSelectEl);
        const newInstance = customSelectInstances.get('fieldSelect');
        if (newInstance) {
          newInstance.renderOptions();
        }
      }
    }
    
    // Setup click handlers for auto-selection (only once)
    setupAutoSelectionHandlers();
    
    // Auto-select field if only one exists
    if (autoSelectAndProgress(fieldSelect, 'fieldSelect', operationSelect)) {
      // Field was auto-selected, show operations immediately
      showOperations();
    }
  } catch (error) {
    console.error('Error loading fields:', error);
    // Show error state
    const trigger = document.querySelector('[data-select-id="fieldSelect"] .custom-select-trigger .custom-select-value');
    if (trigger) trigger.textContent = 'Error loading fields';
    fieldSelect.innerHTML = '<option value="">Error loading fields</option>';
  }
}

// Show and populate Field Operations (locked list of 7 operations)
function showOperations() {
  // Locked list of operations (Visayas farming practices)
  const allOperations = [
    'Pre-Planting',
    'Planting',
    'Post-Planting',
    'Detrashing',
    'Harvesting',
    'Replanting',
    'Ratooning'
  ];
  operationSelect.innerHTML = '<option value="">Select</option>' +
    allOperations.map(op => `<option value="${op}">${op}</option>`).join('');
  
  // Re-initialize custom select after updating options
  const operationSelectInstance = customSelectInstances.get('operationSelect');
  if (operationSelectInstance) {
    operationSelectInstance.renderOptions();
  }
  
  operationWrap.classList.remove('hidden');
  taskTypeWrap.classList.add('hidden');
  dynamicForm.classList.add('hidden');
  boughtItemsSection.classList.add('hidden');
  vehicleUpdatesSection.classList.add('hidden');
  
  // Auto-select operation if only one option exists
  setTimeout(() => {
    autoSelectAndProgress(operationSelect, 'operationSelect', taskType);
  }, 50);
}

// Setup click handlers for auto-selection (called once after fields are loaded)
let autoSelectionHandlersSetup = false;
function setupAutoSelectionHandlers() {
  if (autoSelectionHandlersSetup) return;
  autoSelectionHandlersSetup = true;

  // Handler for fieldSelect click/focus
  const fieldSelectTrigger = document.querySelector(`.custom-select[data-select-id="fieldSelect"] .custom-select-trigger`);
  if (fieldSelectTrigger) {
    fieldSelectTrigger.addEventListener('click', () => {
      // Check if only one field exists and not yet selected
      if (!fieldSelect.value) {
        autoSelectAndProgress(fieldSelect, 'fieldSelect', operationSelect);
      }
    });
  }
}

// Field selection handler - fetch field data and calculate Seed Rate
fieldSelect.addEventListener('change', async function() {
  const fieldId = this.value;
  
  // Don't clear form if we're loading an edit record (but still fetch field data)
  const isEditMode = window._isLoadingEditRecord;
  if (isEditMode) {
    console.log('⏸️ Edit mode: skipping form clear, but fetching field data');
  }
  currentFieldArea = null;
  
  // Clear done tasks cache when field changes (per-field isolation)
  clearDoneTasksCache();
  
  if (!fieldId) {
    // Hide operations and dependent fields if field is deselected
    operationWrap.classList.add('hidden');
    taskTypeWrap.classList.add('hidden');
    dynamicForm.classList.add('hidden');
    boughtItemsSection.classList.add('hidden');
    vehicleUpdatesSection.classList.add('hidden');
    
    // Reset seed rate if field is deselected
    const seedRateInput = document.getElementById('seedRate');
    if (seedRateInput) {
      seedRateInput.value = '';
    }
    return;
  }
  
  try {
    // Fetch field document to get area
    const fieldRef = doc(db, 'fields', fieldId);
    const fieldSnap = await getDoc(fieldRef);
    
    if (fieldSnap.exists()) {
      const fieldData = fieldSnap.data();
      // Try multiple field area property names for compatibility
      currentFieldArea = fieldData.field_size || fieldData.area_size || fieldData.area || fieldData.size || null;
      
      // Calculate Seed Rate if seedRate field exists (for Planting Operation)
      const seedRateInput = document.getElementById('seedRate');
      if (seedRateInput && currentFieldArea) {
        // Formula: Seed Rate = 40,000 × Field Area Size
        const seedRate = 40000 * parseFloat(currentFieldArea);
        seedRateInput.value = seedRate.toFixed(2);
        
        // Trigger update of totalCaneRequired if it exists
        const totalCaneRequiredInput = document.getElementById('totalCaneRequired');
        const numberOfSettsInput = document.getElementById('numberOfSetts');
        if (totalCaneRequiredInput && numberOfSettsInput) {
          const setts = parseFloat(numberOfSettsInput.value) || 0;
          totalCaneRequiredInput.value = (setts * seedRate).toFixed(2);
        }
      }
      
      // Auto-fill Area Covered for Weeding Management (if not manually edited)
      const areaCoveredInput = document.getElementById('areaCovered');
      if (areaCoveredInput && currentFieldArea) {
        // Only auto-fill if user hasn't manually edited
        if (areaCoveredInput.dataset.userEdited !== 'true') {
          areaCoveredInput.value = parseFloat(currentFieldArea).toFixed(2);
        }
      }
    }
    
    // Show operations after field is selected
    // In edit mode, we've already populated operations manually, so just ensure they're visible
    if (!isEditMode) {
    showOperations();
    } else {
      // In edit mode, operations should already be populated by loadRecordForEdit
      // Just make sure the wrap is visible
      if (operationSelect && operationSelect.options.length > 1) {
        operationWrap.classList.remove('hidden');
        // Re-initialize custom select if needed
        const operationSelectInstance = customSelectInstances.get('operationSelect');
        if (operationSelectInstance) {
          operationSelectInstance.renderOptions();
        }
      } else {
        // Fallback: populate operations if they weren't populated yet
        operationWrap.classList.remove('hidden');
        const allOperations = [
          'Pre-Planting',
          'Planting',
          'Post-Planting',
          'Detrashing',
          'Harvesting',
          'Replanting',
          'Ratooning'
        ];
        operationSelect.innerHTML = '<option value="">Select</option>' +
          allOperations.map(op => `<option value="${op}">${op}</option>`).join('');
        
        const operationSelectInstance = customSelectInstances.get('operationSelect');
        if (operationSelectInstance) {
          operationSelectInstance.renderOptions();
        }
      }
    }
  } catch (error) {
    console.error('Error fetching field data:', error);
  }
});


// Field Operation selection handler
operationSelect.onchange = async () => {
  const operation = operationSelect.value;
  const isEditMode = window._isLoadingEditRecord;
  
  if (isEditMode) {
    console.log('⏸️ Edit mode: showing task types without clearing form');
  } else {
    // Clean up dynamically created Rent Cost containers (only in normal mode)
  const existingRentCostContainer = document.getElementById('rentCostContainer');
  if (existingRentCostContainer) existingRentCostContainer.remove();
  const existingTruckRentedContainer = document.getElementById('truckRentedContainer');
  if (existingTruckRentedContainer) existingTruckRentedContainer.remove();
  
    // Clear form only in normal mode
  taskType.value = '';
  dynamicForm.innerHTML = '';
  }
  
  if (!operation) {
    taskTypeWrap.classList.add('hidden');
    if (!isEditMode) {
    dynamicForm.classList.add('hidden');
    boughtItemsSection.classList.add('hidden');
    vehicleUpdatesSection.classList.add('hidden');
    }
    return;
  }
  
  // Special handling for Ratooning - no task types or forms
  if (operation === 'Ratooning') {
    if (!isEditMode) {
    taskTypeWrap.classList.add('hidden');
    dynamicForm.classList.add('hidden');
    boughtItemsSection.classList.add('hidden');
    vehicleUpdatesSection.classList.add('hidden');
    
    // Show confirmation and handle ratooning immediately
    const ratooningConfirm = confirm('Ratooning will archive the current crop cycle and prepare the field for a new cycle. Continue?');
    if (!ratooningConfirm) {
      // Reset operation selection if user cancels
      operationSelect.value = '';
  const operationSelectInstance = customSelectInstances.get('operationSelect');
  if (operationSelectInstance) {
        operationSelectInstance.updateSelectedLabel();
      }
      return;
  }
  
    // Handle ratooning asynchronously
    (async () => {
      try {
        showLoading(true);
        
        // Import ratooning handler
        const { handleRatooning } = await import('../../backend/Handler/growth-tracker.js');
        await handleRatooning(uid, fieldSelect.value);
        
        showLoading(false);
        showNotification('success', 'Ratooning Completed', 'The current crop cycle has been archived and the field is ready for a new cycle.', [
          {
            text: 'OK',
            type: 'primary',
            action: () => {
              location.reload();
            }
          }
        ]);
      } catch (error) {
        console.error('Error handling ratooning:', error);
        showLoading(false);
        showNotification('error', 'Ratooning Failed', error.message || 'An error occurred while processing ratooning.');
        // Reset operation selection on error
        operationSelect.value = '';
        const operationSelectInstance = customSelectInstances.get('operationSelect');
    if (operationSelectInstance) {
      operationSelectInstance.updateSelectedLabel();
    }
      }
    })();
    }
    return;
  }
  
  // Get Task Types based on Field Operation
  const allTasks = operationToTasks[operation] || [];
  
  if (!allTasks.length) {
    taskTypeWrap.classList.add('hidden');
    if (!isEditMode) {
    dynamicForm.classList.add('hidden');
    boughtItemsSection.classList.add('hidden');
    vehicleUpdatesSection.classList.add('hidden');
    }
    return;
  }
  
  // Filter out done tasks (Growth Tracker = Final Authority)
  // Only filter in normal mode (not in edit mode, where we want to show all tasks)
  let availableTasks = allTasks;
  if (!isEditMode && fieldSelect.value) {
    try {
      const doneTasks = await getDoneTasks(fieldSelect.value, operation, allTasks);
      availableTasks = allTasks.filter(task => !doneTasks.has(task));
      
      // Update Field Operation display if all tasks are done
      const operationSelectInstance = customSelectInstances.get('operationSelect');
      if (operationSelectInstance && availableTasks.length === 0) {
        // All tasks completed - make operation non-clickable and show label
        const operationTrigger = document.querySelector('[data-select-id="operationSelect"] .custom-select-trigger');
        if (operationTrigger) {
          operationTrigger.style.cursor = 'not-allowed';
          operationTrigger.style.opacity = '0.7';
          operationTrigger.title = 'All tasks completed';
          
          // Add visual indicator
          const valueEl = operationTrigger.querySelector('.custom-select-value');
          if (valueEl) {
            const originalText = valueEl.textContent;
            valueEl.innerHTML = `${originalText} <span class="text-xs text-gray-500 ml-2">(All tasks completed)</span>`;
          }
        }
      } else if (operationSelectInstance) {
        // Reset operation display if not all tasks are done
        const operationTrigger = document.querySelector('[data-select-id="operationSelect"] .custom-select-trigger');
        if (operationTrigger) {
          operationTrigger.style.cursor = '';
          operationTrigger.style.opacity = '';
          operationTrigger.title = '';
          
          const valueEl = operationTrigger.querySelector('.custom-select-value');
          if (valueEl) {
            // Remove the "(All tasks completed)" text if present
            valueEl.textContent = operationSelect.value || 'Select';
          }
        }
      }
    } catch (error) {
      console.error('Error filtering done tasks:', error);
      // On error, show all tasks (don't hide anything)
      availableTasks = allTasks;
    }
  }
  
  // If all tasks are done and we're not in edit mode, hide task type dropdown
  if (!isEditMode && availableTasks.length === 0) {
    taskTypeWrap.classList.add('hidden');
    dynamicForm.classList.add('hidden');
    boughtItemsSection.classList.add('hidden');
    vehicleUpdatesSection.classList.add('hidden');
    return;
  }
  
  // Show Task Type dropdown
    taskTypeWrap.classList.remove('hidden');
  taskType.innerHTML = '<option value="">Select</option>' +
      availableTasks.map(t => `<option value="${t}">${t}</option>`).join('');
  
  // Re-initialize custom select after updating options
  const taskTypeInstance = customSelectInstances.get('taskType');
  if (taskTypeInstance) {
    taskTypeInstance.renderOptions();
  }
  
  // Only hide form in normal mode (in edit mode, form will be shown when task type is set)
  if (!isEditMode) {
  dynamicForm.classList.add('hidden');
  boughtItemsSection.classList.add('hidden');
  vehicleUpdatesSection.classList.add('hidden');
  
    // Auto-select task type if only one option exists (only in normal mode)
  setTimeout(() => {
    if (autoSelectAndProgress(taskType, 'taskType', null)) {
      // Task type was auto-selected, form will be rendered by taskType change
    }
  }, 50);
  }
};

// Task Type selection handler
taskType.onchange = () => {
  const taskDisplayName = taskType.value;
  
  if (!taskDisplayName) {
    dynamicForm.classList.add('hidden');
    boughtItemsSection.classList.add('hidden');
    vehicleUpdatesSection.classList.add('hidden');
    return;
  }
  
  // Map display name to taskFieldMap key
  const taskKey = taskNameAliases[taskDisplayName] || taskDisplayName;
  renderForm(taskKey);
  
  // Show optional sections after task fields
  boughtItemsSection.classList.remove('hidden');
  vehicleUpdatesSection.classList.remove('hidden');
}

function renderForm(type){
  // Safety check: ensure type is valid and taskFieldMap exists
  if (!type || typeof type !== 'string') {
    console.error('❌ renderForm called with invalid type:', type);
    if (dynamicForm) {
      dynamicForm.innerHTML = '';
      dynamicForm.classList.add('hidden');
    }
    return;
  }
  
  // Safety check: ensure taskFieldMap exists
  if (typeof taskFieldMap === 'undefined' || !taskFieldMap) {
    console.error('❌ taskFieldMap is not defined');
    if (dynamicForm) {
      dynamicForm.innerHTML = '';
      dynamicForm.classList.add('hidden');
    }
    return;
  }
  
  // Clean up any dynamically created Rent Cost containers from previous form
  const existingRentCostContainer = document.getElementById('rentCostContainer');
  if (existingRentCostContainer) {
    existingRentCostContainer.remove();
  }
  const existingTruckRentedContainer = document.getElementById('truckRentedContainer');
  if (existingTruckRentedContainer) {
    existingTruckRentedContainer.remove();
  }
  
  if (!dynamicForm) {
    console.error('❌ dynamicForm element not found');
    return;
  }
  
  if (!dynamicForm) {
    console.error('❌ dynamicForm element not found');
    return;
  }
  
  dynamicForm.innerHTML = '';
  
  // Safety check: ensure taskFieldMap exists and type is valid
  if (!taskFieldMap || typeof taskFieldMap !== 'object') {
    console.error('❌ taskFieldMap is not defined or not an object');
    dynamicForm.classList.add('hidden');
    return;
  }
  
  const fields = taskFieldMap[type];
  
  // Safety check: ensure fields is an array
  if (!Array.isArray(fields)) {
    console.error('❌ fields is not an array for type:', type, 'Got:', fields);
    dynamicForm.classList.add('hidden');
    return;
  }
  
  if (!fields.length) {
    dynamicForm.classList.add('hidden');
    return;
  }
  
  dynamicForm.classList.remove('hidden');

  fields.forEach(f => {
    let inputHTML = '';

    // 🔽 SELECT WITH "Other" OPTION
    if(f.type === 'select'){
      const optionsHTML = `
        <option value="">Select</option>
        ${f.options.map(opt=>`<option value="${opt}">${opt}</option>`).join('')}
      `;
      inputHTML = `
        ${getCustomSelectTemplate(f.id, optionsHTML, 'Select', `required onchange="handleOtherSelect('${f.id}')"`)}
        <input type="text" id="${f.id}_other" placeholder="Please specify" class="w-full border rounded px-3 py-2 mt-2 hidden" />
      `;
    } 

    // 🔢 NUMBER INPUT (regular)
    else if(f.type === 'number'){
      // Special handling for dosage with unit selector
      if(f.id === 'dosage' && f.hasUnit){
        const unitOptionsHTML = `
          <option value="">Select unit</option>
          ${f.unitOptions.map(opt => `<option value="${opt}">${opt}</option>`).join('')}
        `;
        inputHTML = `
          <div class="flex gap-2">
            <input type="number" step="${f.step || 1}" inputmode="decimal" id="${f.id}" class="flex-1 border rounded px-3 py-2" value="0" required />
            ${getCustomSelectTemplate(f.id + 'Unit', unitOptionsHTML, 'Select unit', 'required')}
          </div>
        `;
      }
      // Special handling for areaCovered with auto-fill
      else if(f.id === 'areaCovered' && f.autoFill){
        inputHTML = `<input type="number" step="${f.step || 1}" inputmode="decimal" id="${f.id}" class="w-full border rounded px-3 py-2" value="0" required />`;
      }
      // Special handling for chemical cost calculation (Quantity × Price)
      else if(f.id === 'chemicalCost' && f.readonly){
        // This will be rendered after quantity and price fields
        inputHTML = `<input type="number" step="${f.step || 1}" inputmode="decimal" id="${f.id}" class="w-full border rounded px-3 py-2 bg-gray-100" readonly />`;
      }
      // Special handling for enhanced Labor Cost
      else if(f.id === 'laborCost' && f.enhanced){
        // Enhanced Labor Cost structure with Rate, Workers, and calculated total
        // Uses external Start Date and End Date for calculations
        inputHTML = `
          <div id="laborCostEnhancedContainer" class="space-y-3 p-3 border rounded-lg bg-gray-50">
            <div class="text-xs font-semibold text-gray-700 mb-2">${f.label} Details</div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
              <div>
                <label class="text-xs font-medium">Rate per Day</label>
                <input type="number" step="0.01" id="laborRatePerDay" class="w-full border rounded px-3 py-2" value="0" required />
              </div>
              <div>
                <label class="text-xs font-medium">Number of Workers</label>
                <input type="number" id="laborWorkers" class="w-full border rounded px-3 py-2" value="0" required />
              </div>
              <div class="md:col-span-2">
                <label class="text-xs font-medium">Working Days (auto-calculated from Start Date and End Date)</label>
                <input type="number" id="laborWorkingDays" class="w-full border rounded px-3 py-2 bg-gray-100" readonly />
              </div>
              <div class="md:col-span-2">
                <label class="text-xs font-semibold">Total Labor Cost (auto-calculated)</label>
                <input type="number" step="0.01" id="laborCost" class="w-full border rounded px-3 py-2 bg-gray-100 font-semibold" readonly />
              </div>
            </div>
          </div>
        `;
      }
      // check kung weight or laborCost (legacy dynamic input)
      else if(f.id === 'weight' || (f.id === 'laborCost' && !f.enhanced)){
        inputHTML = `
          <div id="${f.id}Container">
            <div class="flex mb-2">
              <input type="number" class="${f.id}Input border rounded px-3 py-2 mr-2" value="0" />
              <button type="button" id="add${f.id}Btn" class="border rounded px-3 py-2">+</button>
            </div>
            <div id="${f.id}Sum" class="font-bold">Total ${f.label}: 0</div>
            <input type="hidden" id="${f.id}" />
          </div>
        `;
      } else {
        const readonlyAttr = f.readonly ? 'readonly' : '';
        inputHTML = `<input type="number" step="${f.step || 1}" inputmode="decimal" id="${f.id}" class="w-full border rounded px-3 py-2" value="0" ${readonlyAttr} ${readonlyAttr ? '' : 'required'} />`;
      }
    }

    // 📅 DATE
    else if(f.type === 'date'){
      // Special handling for startDate fields - add current date dropdown
      if(f.id === 'startDate'){
        const today = new Date();
        // Get local date components to avoid timezone issues
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const todayFormattedDisplay = today.toLocaleDateString('en-US', { 
          weekday: 'short', 
          year: 'numeric', 
          month: 'short', 
          day: 'numeric' 
        });
        inputHTML = `
          <div class="date-input-wrapper">
            <input type="date" id="${f.id}" class="w-full border rounded px-3 py-2" required />
            <div id="${f.id}_dropdown" class="current-date-dropdown">
              <div class="current-date-option" onclick="event.stopPropagation(); selectCurrentDate('${f.id}');">
                <div class="date-label">Today</div>
                <div class="date-value">${todayFormattedDisplay}</div>
              </div>
            </div>
          </div>
        `;
      } else {
        inputHTML = `<input type="date" id="${f.id}" class="w-full border rounded px-3 py-2" required />`;
      }
    }

    // 💰 FUEL COST DYNAMIC INPUTS
    else if(f.type === 'fuel'){
      inputHTML = `
        <div id="fuelContainer">
          <div class="flex mb-2">
            <input type="number" class="fuelInput border rounded px-3 py-2 mr-2" value="0" />
            <button type="button" id="addFuelBtn" class="border rounded px-3 py-2">+</button>
          </div>
          <div id="fuelSum" class="font-bold">Total Fuel Cost: 0</div>
        </div>
      `;
    }

    // 📝 TEXTAREA (for notes/remarks)
    else if(f.type === 'textarea'){
      inputHTML = `<textarea id="${f.id}" class="w-full border rounded px-3 py-2" rows="3" required></textarea>`;
    }

    // ✏️ TEXT (DEFAULT)
    else {
      const readonlyAttr = f.readonly ? 'readonly' : '';
      inputHTML = `<input type="text" id="${f.id}" class="w-full border rounded px-3 py-2" ${readonlyAttr} ${readonlyAttr ? '' : 'required'} />`;
    }

    // Append field
    dynamicForm.innerHTML += `
      <div class="mb-4">
        <label class="text-xs font-medium">${f.label}</label>
        ${inputHTML}
      </div>
    `;
  });

  // Always add Notes / Remarks field at the bottom (optional, always visible)
  // Safety check: ensure fields is still an array
  if (!Array.isArray(fields)) {
    console.error('❌ fields is not an array when checking for notes field');
    return;
  }
  const hasNotesField = fields.some(f => f && (f.id === 'notes' || f.id === 'remarks'));
  if (!hasNotesField) {
    dynamicForm.innerHTML += `
      <div class="mb-4">
        <label class="text-xs font-medium">Notes / Remarks (Mga Pahinumdom) <span class="text-gray-500 text-xs">(Optional)</span></label>
        <textarea id="notes" class="w-full border rounded px-3 py-2" rows="3" placeholder="Add any additional notes or remarks..."></textarea>
      </div>
    `;
  }

  // Initialize custom selects within the dynamic form
  // Safety check: ensure fields is an array before using filter/forEach
  if (!Array.isArray(fields)) {
    console.error('❌ fields is not an array when initializing custom selects. Type:', typeof fields, 'Value:', fields);
    return;
  }
  
  const selectFields = fields.filter(f => f && f.type === 'select');
  if (!Array.isArray(selectFields)) {
    console.error('❌ selectFields is not an array after filter');
    return;
  }
  
  selectFields.forEach(f => {
      const selectEl = document.getElementById(f.id);
      if (selectEl) {
        initializeCustomSelect(selectEl);
        
        // Handle conditional field visibility (dependsOn)
        if (f.dependsOn) {
          const dependentFieldId = f.dependsOn.field;
          const dependentField = document.getElementById(dependentFieldId);
          if (dependentField) {
            const updateVisibility = () => {
              const dependentValue = dependentField.value;
              const shouldShow = f.dependsOn.values.includes(dependentValue);
              const fieldContainer = selectEl.closest('.mb-4');
              if (fieldContainer) {
                fieldContainer.style.display = shouldShow ? '' : 'none';
                // Also update required attribute
                if (selectEl.hasAttribute('required')) {
                  selectEl.required = shouldShow;
                }
              }
            };
            
            // Listen to both custom select and native select changes
            dependentField.addEventListener('change', updateVisibility);
            updateVisibility(); // Initial check
          }
        }
      }
    });
  
  // Handle conditional visibility for non-select fields with dependsOn
  // Safety check: ensure fields is still an array
  if (!Array.isArray(fields)) {
    console.error('❌ fields is not an array when handling conditional visibility');
    return;
  }
  
  const dependsOnFields = fields.filter(f => f && f.dependsOn && f.type !== 'select');
  if (!Array.isArray(dependsOnFields)) {
    console.error('❌ dependsOnFields is not an array after filter');
    return;
  }
  
  dependsOnFields.forEach(f => {
      const fieldEl = document.getElementById(f.id);
      if (fieldEl) {
        const dependentFieldId = f.dependsOn.field;
        const dependentField = document.getElementById(dependentFieldId);
        if (dependentField) {
          const updateVisibility = () => {
            const dependentValue = dependentField.value;
            const shouldShow = f.dependsOn.values.includes(dependentValue);
            const fieldContainer = fieldEl.closest('.mb-4');
            if (fieldContainer) {
              fieldContainer.style.display = shouldShow ? '' : 'none';
              // Also update required attribute
              if (fieldEl.hasAttribute('required')) {
                fieldEl.required = shouldShow;
              }
            }
          };
          
          // Listen to both custom select and native select changes
          dependentField.addEventListener('change', updateVisibility);
          updateVisibility(); // Initial check
        }
      }
    });

  // Add event listeners for start date inputs to show dropdown on click/focus
  const startDateInputs = document.querySelectorAll('input[type="date"][id="startDate"]');
  startDateInputs.forEach(input => {
    // Show dropdown when date input is clicked
    input.addEventListener('click', function() {
      const dropdown = document.getElementById(`${input.id}_dropdown`);
      if (dropdown) {
        // Close all other dropdowns
        document.querySelectorAll('.current-date-dropdown.show').forEach(d => {
          if (d.id !== dropdown.id) {
            d.classList.remove('show');
          }
        });
        // Show this dropdown
        dropdown.classList.add('show');
      }
    });
    
    // Also show on focus
    input.addEventListener('focus', function() {
      const dropdown = document.getElementById(`${input.id}_dropdown`);
      if (dropdown) {
        // Close all other dropdowns
        document.querySelectorAll('.current-date-dropdown.show').forEach(d => {
          if (d.id !== dropdown.id) {
            d.classList.remove('show');
          }
        });
        // Show this dropdown
        dropdown.classList.add('show');
      }
    });
  });

  // Close dropdowns when clicking outside
  document.addEventListener('click', function(event) {
    // Don't close if clicking on the date input wrapper or dropdown option
    if (!event.target.closest('.date-input-wrapper') && 
        !event.target.closest('.current-date-option') &&
        !event.target.closest('.current-date-dropdown')) {
      document.querySelectorAll('.current-date-dropdown.show').forEach(dropdown => {
        dropdown.classList.remove('show');
      });
    }
  });

  // --- SPECIAL HANDLING ---

  // Comprehensive list of ALL cost-related field IDs (ONLY fields that represent money/cost)
  // This list is exhaustive and includes all cost fields from Pre-Planting to Replanting
  const costFieldIds = [
    // Standard cost fields
    'fuelCost',
    'materialCost',
    'fertilizerCost',
    'chemicalCost',
    'haulingCost',
    'harvestCost',
    'transportCost',
    'cost', // Legacy field name
    // Other expense fields
    'haulingExpense',
    'rentCost' // Dynamically created field
  ];

  // List of field IDs that should NEVER be included in total cost calculation
  // These are non-cost fields (quantities, measurements, counts, etc.)
  const excludedFieldIds = [
    'totalCost', // Don't include itself
    'laborCost', // Handled separately (enhanced or legacy) - only the final calculated total
    'fuel', // Special case, handled separately if needed
    // Labor cost detail fields (NOT costs, only used to calculate laborCost)
    'laborRatePerDay', 'laborWorkers', 'laborWorkingDays', 'ratePerDay',
    // Non-cost fields
    'workers', 'operators', 'numberOfWorkers', 'numberOfOperators',
    'areaCovered', 'areaHarvested', 'areaTreated', 'fieldArea',
    'quantity', 'quantityPrepared', 'dosage',
    'yieldTcHa', 'totalCaneYield', 'caneLoaded', 'weight',
    'distance', 'depth', 'rowCoverage', 'rowsCovered',
    'germinationRate', 'cropAge', 'height', 'tillersPerHill',
    'estimatedYield', 'brix',
    'startDate', 'endDate' // Dates are not costs
  ];

  // --- Universal Auto-calculate Total Cost ---
  // This function calculates totalCost by summing ONLY cost-related fields
  // It explicitly excludes all non-cost fields (quantities, measurements, counts, etc.)
  // Make it available globally so it can be accessed from loadRecordForEdit
  window.updateTotalCost = function updateTotalCost(){
    const totalCostInput = document.getElementById('totalCost');
    if(!totalCostInput) return;
    
    let total = 0;
    
    // Check for enhanced labor cost (readonly calculated field) - ALWAYS include if present
    // This is the total labor cost from the enhanced labor cost details
    const laborCostEnhancedContainer = document.getElementById('laborCostEnhancedContainer');
    const enhancedLaborCostInput = document.getElementById('laborCost');
    if(laborCostEnhancedContainer && enhancedLaborCostInput) {
      // Only include if it's the readonly calculated total (enhanced labor cost)
      // The enhanced labor cost input becomes readonly after calculation
      if(enhancedLaborCostInput.readonly || enhancedLaborCostInput.hasAttribute('readonly')) {
        total += parseFloat(enhancedLaborCostInput.value) || 0;
      }
    }
    
    // Check for legacy 'laborCost' container (special dynamic input case)
    const laborCostContainer = document.getElementById('laborCostContainer');
    const hasLaborCostContainer = !!laborCostContainer;
    if(hasLaborCostContainer) {
      const laborCostHidden = document.getElementById('laborCost');
      if(laborCostHidden) {
        total += parseFloat(laborCostHidden.value) || 0;
      }
    }
    
    // Explicitly include Rent Cost if it exists (dynamically created field)
    const rentCostInput = document.getElementById('rentCost');
    if(rentCostInput && rentCostInput.type === 'number') {
      total += parseFloat(rentCostInput.value) || 0;
    }
    
    // Sum ONLY the explicitly listed cost-related fields that exist in the form
    costFieldIds.forEach(fieldId => {
      // Skip laborCost if it's in a legacy dynamic container or enhanced container (already handled above)
      if(fieldId === 'laborCost' && (hasLaborCostContainer || laborCostEnhancedContainer)) {
        return;
      }
      
      const field = document.getElementById(fieldId);
      if(field && field.type === 'number') {
        // Double-check: ensure this field is NOT in the excluded list
        if(excludedFieldIds.includes(fieldId)) {
          return; // Skip excluded fields
        }
        
        // Include readonly fields (like calculated costs such as chemicalCost)
        // Skip if it's inside a legacy dynamic container (handled separately above)
        const container = field.closest('#' + fieldId + 'Container');
        if(!container) {
          const value = parseFloat(field.value) || 0;
          total += value;
        }
      }
    });
    
    // Update totalCost with 2 decimal places
    totalCostInput.value = total.toFixed(2);
  }

  // 1️⃣ Dynamic inputs handler (weight, laborCost, fuel)
  // Safety check: ensure array exists before forEach
  const dynamicFields = ['weight','laborCost','fuel'];
  if (!Array.isArray(dynamicFields)) {
    console.error('❌ dynamicFields is not an array');
    return;
  }
  dynamicFields.forEach(field => {
    const container = document.getElementById(field + 'Container');
    if(!container) return;

    let count = 1;
    const maxInputs = 5;

    const addBtn = document.getElementById('add' + field + 'Btn');
    if(addBtn){
      addBtn.addEventListener('click', () => {
        if(count >= maxInputs) return;
        const newDiv = document.createElement('div');
        newDiv.classList.add('flex','mb-2');
        newDiv.innerHTML = `<input type="number" class="${field}Input border rounded px-3 py-2 mr-2" value="0" />`;
        container.insertBefore(newDiv, document.getElementById(field + 'Sum'));
        count++;
        newDiv.querySelector('input').addEventListener('input', updateSum);
        updateSum();
      });
    }

    function updateSum(){
      const inputs = container.querySelectorAll('.' + field + 'Input');
      let sum = 0;
      inputs.forEach(i => sum += Number(i.value) || 0);
      document.getElementById(field + 'Sum').innerText = `Total ${field === 'weight' ? 'Cane Weight' : field==='laborCost' ? 'Labor Cost' : 'Fuel Cost'}: ${sum}`;
      const hiddenInput = document.getElementById(field);
      if(hiddenInput) hiddenInput.value = sum;
      // Trigger totalCost recalculation when dynamic fields change
      if(field === 'fuel' || field === 'laborCost') {
        updateTotalCost();
      }
    }

    // Initial attach
    container.querySelectorAll('input').forEach(i => i.addEventListener('input', updateSum));
    updateSum();
  });

  // 2️⃣ Attach listeners to all cost-related fields for auto-calculation
  // Note: costFieldIds is already defined above, just use it here
  // Add 'laborCost' and 'rentCost' to the list for event listeners
  const costFieldIdsForListeners = [...costFieldIds, 'laborCost', 'rentCost'];
  
  // Handle dynamic container fields (fuel, laborCost) - listeners already added in updateSum
  // Just need to make sure they trigger updateTotalCost, which is already done in updateSum
  
  // Attach listeners to all regular cost fields
  costFieldIdsForListeners.forEach(fieldId => {
    const field = document.getElementById(fieldId);
    if(field && field.type === 'number' && !field.readonly) {
      field.addEventListener('input', updateTotalCost);
      field.addEventListener('change', updateTotalCost);
    }
  });
  
  // Also listen for any cost-related fields that might be dynamically created
  // Use event delegation on the form container
  const dynamicFormEl = document.getElementById('dynamicForm');
  if(dynamicFormEl) {
    // Remove any existing listener to avoid duplicates
    const newHandler = (e) => {
      if(e.target.type === 'number' && !e.target.readonly) {
        const fieldId = e.target.id;
        // Check if it's a cost-related field
        if(costFieldIdsForListeners.includes(fieldId) || 
           (fieldId.toLowerCase().includes('cost') && fieldId !== 'totalCost')) {
          updateTotalCost();
        }
      }
    };
    dynamicFormEl.addEventListener('input', newHandler);
  }
  
  // Initial calculation
  updateTotalCost();

  // --- Handle computed fields ---
  
  // --- Enhanced Labor Cost Calculation ---
  const laborCostEnhancedContainer = document.getElementById('laborCostEnhancedContainer');
  if (laborCostEnhancedContainer) {
    const laborRatePerDayInput = document.getElementById('laborRatePerDay');
    const laborWorkersInput = document.getElementById('laborWorkers');
    // Use external Start Date and End Date instead of internal ones
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const laborWorkingDaysInput = document.getElementById('laborWorkingDays');
    const laborCostTotalInput = document.getElementById('laborCost');
    
    // Function to calculate working days (inclusive of both dates)
    // Uses external Start Date and End Date
    const calculateWorkingDays = () => {
      if (!startDateInput || !endDateInput) return 0;
      
      const startDate = startDateInput.value;
      const endDate = endDateInput.value;
      
      if (!startDate || !endDate) {
        if (laborWorkingDaysInput) laborWorkingDaysInput.value = '';
        return 0;
      }
      
      // Validate: End Date must be >= Start Date
      const start = new Date(startDate);
      const end = new Date(endDate);
      
      if (end < start) {
        // Show validation error on external end date input
        endDateInput.classList.add('border-red-500');
        endDateInput.setCustomValidity('End Date must be on or after Start Date');
        if (laborWorkingDaysInput) laborWorkingDaysInput.value = '';
        return 0;
      } else {
        endDateInput.classList.remove('border-red-500');
        endDateInput.setCustomValidity('');
      }
      
      // Calculate days (inclusive): difference + 1
      const diffTime = Math.abs(end - start);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
      
      if (laborWorkingDaysInput) {
        laborWorkingDaysInput.value = diffDays;
      }
      
      return diffDays;
    };
    
    // Function to calculate total labor cost
    const calculateTotalLaborCost = () => {
      const rate = parseFloat(laborRatePerDayInput?.value) || 0;
      const workers = parseFloat(laborWorkersInput?.value) || 0;
      const workingDays = calculateWorkingDays();
      
      const total = rate * workers * workingDays;
      
      if (laborCostTotalInput) {
        laborCostTotalInput.value = total.toFixed(2);
        // Trigger total cost update
        updateTotalCost();
      }
    };
    
    // Attach event listeners
    if (laborRatePerDayInput) {
      laborRatePerDayInput.addEventListener('input', calculateTotalLaborCost);
      laborRatePerDayInput.addEventListener('change', calculateTotalLaborCost);
    }
    if (laborWorkersInput) {
      laborWorkersInput.addEventListener('input', calculateTotalLaborCost);
      laborWorkersInput.addEventListener('change', calculateTotalLaborCost);
    }
    // Listen to external Start Date and End Date changes
    if (startDateInput) {
      startDateInput.addEventListener('change', calculateTotalLaborCost);
    }
    if (endDateInput) {
      endDateInput.addEventListener('change', calculateTotalLaborCost);
    }
    
    // Initial calculation if dates are already set
    calculateTotalLaborCost();
  }
  
  // --- Area Covered Auto-Fill (Weeding Management) ---
  const areaCoveredInput = document.getElementById('areaCovered');
  if (areaCoveredInput) {
    // Track if user has manually edited the field (stored in data attribute)
    if (!areaCoveredInput.dataset.userEdited) {
      areaCoveredInput.dataset.userEdited = 'false';
    }
    
    // Auto-fill from field area if available and not manually edited
    if (currentFieldArea && areaCoveredInput.dataset.userEdited === 'false') {
      areaCoveredInput.value = parseFloat(currentFieldArea).toFixed(2);
    }
    
    // Track manual edits
    areaCoveredInput.addEventListener('input', function() {
      this.dataset.userEdited = 'true';
      
      // Prevent negative values
      if (parseFloat(this.value) < 0) {
        this.value = 0;
        this.classList.add('border-red-500');
        setTimeout(() => this.classList.remove('border-red-500'), 2000);
      }
    });
    
    // Also track on focus/blur to detect programmatic vs manual changes
    areaCoveredInput.addEventListener('focus', function() {
      this.dataset.wasEmpty = this.value === '' || this.value === '0';
    });
    
    // Validation for negative values
    areaCoveredInput.addEventListener('change', function() {
      if (parseFloat(this.value) < 0) {
        this.value = 0;
        this.classList.add('border-red-500');
        setTimeout(() => this.classList.remove('border-red-500'), 2000);
      }
    });
  }
  
  // --- Dosage Unit Selector Initialization (Weeding Management) ---
  const dosageUnitSelect = document.getElementById('dosageUnit');
  if (dosageUnitSelect) {
    initializeCustomSelect(dosageUnitSelect);
  }
  
  // --- Chemical Cost (Weeding Management) ---
  // Chemical Cost is now a manual input and is included in Total Cost auto-calculation.
  
  // Seed Rate auto-calculation (if field is already selected)
  const seedRateInput = document.getElementById('seedRate');
  if (seedRateInput && currentFieldArea) {
    // Formula: Seed Rate = 40,000 × Field Area Size
    const seedRate = 40000 * parseFloat(currentFieldArea);
    seedRateInput.value = seedRate.toFixed(2);
  }
  
  // Total Cane Required = Number of Setts × Seed Rate
  const numberOfSettsInput = document.getElementById('numberOfSetts');
  const totalCaneRequiredInput = document.getElementById('totalCaneRequired');
  
  if (numberOfSettsInput && seedRateInput && totalCaneRequiredInput) {
    const updateTotalCaneRequired = () => {
      const setts = parseFloat(numberOfSettsInput.value) || 0;
      const rate = parseFloat(seedRateInput.value) || 0;
      totalCaneRequiredInput.value = (setts * rate).toFixed(2);
    };
    
    numberOfSettsInput.addEventListener('input', updateTotalCaneRequired);
    // Note: seedRate is readonly, so we don't need to listen to its changes
    updateTotalCaneRequired();
  }

  // --- Calculate Expected Harvest Date based on Date Planted and Variety ---
  const expectedHarvestDateInput = document.getElementById('expectedHarvestDate');
  const varietyInput = document.getElementById('variety');
  const startDateForHarvest = document.getElementById('startDate');
  
  if (expectedHarvestDateInput && varietyInput && startDateForHarvest) {
    // Import shared harvest date calculation function
    import('../../backend/Handler/growth-tracker.js').then(({ calculateExpectedHarvestDateMonths }) => {
      const updateExpectedHarvestDate = () => {
        const plantingDate = startDateForHarvest.value;
        const variety = varietyInput.value;
        
        if (!plantingDate || !variety || variety === 'Others') {
          expectedHarvestDateInput.value = '';
          return;
        }

        // Use shared function for consistent calculation across system
        const result = calculateExpectedHarvestDateMonths(plantingDate, variety);
        if (result) {
          expectedHarvestDateInput.value = result.formatted;
        } else {
          expectedHarvestDateInput.value = '';
        }
      };

      startDateForHarvest.addEventListener('change', updateExpectedHarvestDate);
      varietyInput.addEventListener('change', updateExpectedHarvestDate);
      updateExpectedHarvestDate();
    }).catch(err => {
      console.error('Error loading harvest date calculation:', err);
      // Fallback to empty if import fails
      expectedHarvestDateInput.value = '';
    });
  }

  // --- Handle Mechanical and Animal-Drawn selection to show rent question ---
  const methodFields = ['equipment', 'method', 'plantingMethod', 'cleaningMethod', 'harvestMethod'];
  methodFields.forEach(fieldId => {
    const select = document.getElementById(fieldId);
    if (select) {
      const hasMechanical = select.options && Array.from(select.options).some(opt => opt.value === 'Mechanical' || opt.value.includes('Mechanical'));
      const hasAnimal = select.options && Array.from(select.options).some(opt => opt.value === 'Animal-Drawn' || opt.value.includes('Animal') || opt.value.includes('Animal-Drawn'));
      
      if (hasMechanical || hasAnimal) {
        select.addEventListener('change', function() {
          const isMechanical = this.value === 'Mechanical' || this.value.includes('Mechanical');
          const isAnimal = this.value === 'Animal-Drawn' || this.value.includes('Animal-Drawn') || (this.value.includes('Animal') && !this.value.includes('Mechanical'));
          const truckRentedContainer = document.getElementById('truckRentedContainer');
          const rentCostContainer = document.getElementById('rentCostContainer');
          
          if (isMechanical || isAnimal) {
            // Determine label based on selection
            const rentLabel = isMechanical ? 'Is the truck rented?' : 'Is the animal/equipment rented?';
            
            // Check if container already exists
            if (!truckRentedContainer) {
              // Find the parent div and insert after the current field
              const currentFieldDiv = this.closest('.mb-4');
              if (currentFieldDiv) {
                const newDiv = document.createElement('div');
                newDiv.id = 'truckRentedContainer';
                newDiv.className = 'mb-4';
                newDiv.innerHTML = `
                  <label class="text-xs font-medium">${rentLabel} <span class="text-red-500">*</span></label>
                  <select id="truckRented" class="w-full border rounded px-3 py-2" required>
                    <option value="">Select</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                `;
                currentFieldDiv.parentNode.insertBefore(newDiv, currentFieldDiv.nextSibling);
                
                // Initialize custom select for truckRented
                const truckRentedSelect = document.getElementById('truckRented');
                if (truckRentedSelect) {
                  initializeCustomSelect(truckRentedSelect);
                  
                  // Add handler for truckRented change to show/hide Rent Cost
                  truckRentedSelect.addEventListener('change', function() {
                    const rentCostContainerEl = document.getElementById('rentCostContainer');
                    
                    if (this.value === 'Yes') {
                      if (!rentCostContainerEl) {
                        // Create Rent Cost field
                        const truckRentedDiv = document.getElementById('truckRentedContainer');
                        if (truckRentedDiv) {
                          const rentCostDiv = document.createElement('div');
                          rentCostDiv.id = 'rentCostContainer';
                          rentCostDiv.className = 'mb-4';
                          rentCostDiv.innerHTML = `
                            <label class="text-xs font-medium">Rent Cost <span class="text-red-500">*</span></label>
                            <input type="number" step="0.01" id="rentCost" class="w-full border rounded px-3 py-2" required />
                          `;
                          truckRentedDiv.parentNode.insertBefore(rentCostDiv, truckRentedDiv.nextSibling);
                          
                          // Add event listener for rentCost to update total cost
                          const rentCostInput = document.getElementById('rentCost');
                          if (rentCostInput) {
                            const updateTotalCostFn = window.updateTotalCost || (typeof updateTotalCost !== 'undefined' ? updateTotalCost : null);
                            if (updateTotalCostFn && typeof updateTotalCostFn === 'function') {
                              rentCostInput.addEventListener('input', updateTotalCostFn);
                              rentCostInput.addEventListener('change', updateTotalCostFn);
                            }
                          }
                        }
                      } else {
                        rentCostContainerEl.classList.remove('hidden');
                        const rentCostInput = document.getElementById('rentCost');
                        if (rentCostInput) rentCostInput.required = true;
                      }
                    } else {
                      if (rentCostContainerEl) {
                        rentCostContainerEl.classList.add('hidden');
                        const rentCostInput = document.getElementById('rentCost');
                        if (rentCostInput) {
                          rentCostInput.required = false;
                          rentCostInput.value = '';
                        }
                        updateTotalCost();
                      }
                    }
                  });
                }
              }
            } else {
              // Update label if container exists
              const labelEl = truckRentedContainer.querySelector('label');
              if (labelEl) {
                labelEl.innerHTML = `${rentLabel} <span class="text-red-500">*</span>`;
              }
              truckRentedContainer.classList.remove('hidden');
              // Re-attach handler if needed (when form is re-rendered)
              const truckRentedSelect = document.getElementById('truckRented');
              if (truckRentedSelect && !truckRentedSelect.dataset.rentHandlerAttached) {
                truckRentedSelect.dataset.rentHandlerAttached = 'true';
                truckRentedSelect.addEventListener('change', function() {
                  const rentCostContainerEl = document.getElementById('rentCostContainer');
                  
                  if (this.value === 'Yes') {
                    if (!rentCostContainerEl) {
                      const truckRentedDiv = document.getElementById('truckRentedContainer');
                      if (truckRentedDiv) {
                        const rentCostDiv = document.createElement('div');
                        rentCostDiv.id = 'rentCostContainer';
                        rentCostDiv.className = 'mb-4';
                        rentCostDiv.innerHTML = `
                          <label class="text-xs font-medium">Rent Cost <span class="text-red-500">*</span></label>
                          <input type="number" step="0.01" id="rentCost" class="w-full border rounded px-3 py-2" required />
                        `;
                        truckRentedDiv.parentNode.insertBefore(rentCostDiv, truckRentedDiv.nextSibling);
                        
                        const rentCostInput = document.getElementById('rentCost');
                        if (rentCostInput) {
                          rentCostInput.addEventListener('input', updateTotalCost);
                          rentCostInput.addEventListener('change', updateTotalCost);
                        }
                      }
                    } else {
                      rentCostContainerEl.classList.remove('hidden');
                      const rentCostInput = document.getElementById('rentCost');
                      if (rentCostInput) rentCostInput.required = true;
                    }
                  } else {
                    if (rentCostContainerEl) {
                      rentCostContainerEl.classList.add('hidden');
                      const rentCostInput = document.getElementById('rentCost');
                      if (rentCostInput) {
                        rentCostInput.required = false;
                        rentCostInput.value = '';
                      }
                      updateTotalCost();
                    }
                  }
                });
              }
            }
          } else {
            // Hide rent question and rent cost when Method is not Mechanical or Animal-Drawn
            const truckRentedContainerEl = document.getElementById('truckRentedContainer');
            if (truckRentedContainerEl) {
              truckRentedContainerEl.classList.add('hidden');
              const truckRentedSelect = document.getElementById('truckRented');
              if (truckRentedSelect) {
                truckRentedSelect.value = '';
                truckRentedSelect.dataset.rentHandlerAttached = '';
              }
            }
            const rentCostContainerEl = document.getElementById('rentCostContainer');
            if (rentCostContainerEl) {
              rentCostContainerEl.classList.add('hidden');
              const rentCostInput = document.getElementById('rentCost');
              if (rentCostInput) {
                rentCostInput.value = '';
                rentCostInput.required = false;
              }
              updateTotalCost();
            }
          }
        });
      }
    }
  });

  // --- Legacy labor cost calculation (only if enhanced version doesn't exist) ---
  const legacyLaborCostContainer = document.getElementById('laborCostEnhancedContainer');
  if (!legacyLaborCostContainer) {
    // Only run legacy calculation if enhanced version is not present
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const laborRateInput = document.getElementById('laborRatePerDay');
    const laborCostInput = document.getElementById('laborCost');
    
    if (startDateInput && endDateInput && laborCostInput && !laborCostInput.closest('#' + laborCostInput.id + 'Container')) {
      // Only if laborCost is a regular input, not the dynamic container type or enhanced version
      const updateLaborCostFromDates = () => {
        const startDate = startDateInput.value;
        const endDate = endDateInput.value;
        const laborRate = laborRateInput ? (parseFloat(laborRateInput.value) || 0) : 0;
        
        if (startDate && endDate) {
          const start = new Date(startDate);
          const end = new Date(endDate);
          const diffTime = Math.abs(end - start);
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 to include both start and end days
          
          if (laborRate > 0) {
            laborCostInput.value = (laborRate * diffDays).toFixed(2);
            updateTotalCost();
          }
        }
      };
      
      if (laborRateInput) {
        laborRateInput.addEventListener('input', updateLaborCostFromDates);
      }
      startDateInput.addEventListener('change', updateLaborCostFromDates);
      endDateInput.addEventListener('change', updateLaborCostFromDates);
      updateLaborCostFromDates();
    }
  }

}

// Handle "Other" input for selects
function handleOtherSelect(id){
  const select = document.getElementById(id);
  const otherInput = document.getElementById(`${id}_other`);
  if(select.value === 'Other' || select.value === 'Others'){
    otherInput.classList.remove('hidden');
    otherInput.required = true;
  } else {
    otherInput.classList.add('hidden');
    otherInput.required = false;
    otherInput.value = '';
  }
}

// Select current date and fill the input
window.selectCurrentDate = function(fieldId) {
  const input = document.getElementById(fieldId);
  const dropdown = document.getElementById(`${fieldId}_dropdown`);
  
  if (input) {
    // Calculate current date at the time of selection to ensure accuracy
    const today = new Date();
    // Get local date components to avoid timezone issues
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const day = String(today.getDate()).padStart(2, '0');
    const todayFormatted = `${year}-${month}-${day}`;
    
    // Set the date value - use the freshly calculated date
    input.value = todayFormatted;
    
    // Close all dropdowns immediately
    document.querySelectorAll('.current-date-dropdown').forEach(d => {
      d.classList.remove('show');
    });
    
    // Trigger change event to update any dependent calculations
    setTimeout(() => {
      const changeEvent = new Event('change', { bubbles: true });
      input.dispatchEvent(changeEvent);
    }, 10);
    
    // Blur the input to remove focus and hide any native date picker
    setTimeout(() => {
      input.blur();
    }, 50);
  }
};


// Optional sections handlers
let boughtItemsCount = 0;

const toggleBoughtItemsBtn = document.getElementById('toggleBoughtItems');
const boughtItemsContent = document.getElementById('boughtItemsContent');
const boughtItemsList = document.getElementById('boughtItemsList');
const addBoughtItemBtn = document.getElementById('addBoughtItemBtn');

if (toggleBoughtItemsBtn && boughtItemsContent) {
  toggleBoughtItemsBtn.onclick = () => {
    const isHidden = boughtItemsContent.classList.contains('hidden');
    if (isHidden) {
      boughtItemsContent.classList.remove('hidden');
      toggleBoughtItemsBtn.textContent = 'Hide Section';
    } else {
      boughtItemsContent.classList.add('hidden');
      toggleBoughtItemsBtn.textContent = 'Show Section';
    }
  };
}

if (addBoughtItemBtn && boughtItemsList) {
  addBoughtItemBtn.onclick = () => {
    boughtItemsCount++;
    const itemDiv = document.createElement('div');
    itemDiv.className = 'border rounded p-3 space-y-2';
    const unitSelectId = `boughtUnit_${boughtItemsCount}`;
    const unitOptions = `
      <option value="">Select unit</option>
      <option value="kg">Kilogram (kg)</option>
      <option value="bag">Bag/s</option>
      <option value="sack">Sack/s</option>
      <option value="ton">Ton/s</option>
      <option value="liter">Liter/s</option>
      <option value="gallon">Gallon/s</option>
      <option value="pcs">Piece/s</option>
      <option value="bundle">Bundle/s</option>
      <option value="box">Box/es</option>
      <option value="hectare">Hectare/s</option>
      <option value="others">Others</option>
    `;
    
    itemDiv.innerHTML = `
      <div class="flex justify-between items-center mb-2">
        <span class="text-xs font-medium">Item ${boughtItemsCount}</span>
        <button type="button" class="text-red-500 text-xs" onclick="this.closest('.border').remove()">Remove</button>
      </div>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
        <div>
          <label class="text-xs">Item Name</label>
          <input type="text" class="bought-item-name w-full px-2 py-1 border rounded text-sm" />
        </div>
        <div>
          <label class="text-xs">Quantity</label>
          <input type="number" step="0.01" class="bought-item-qty w-full px-2 py-1 border rounded text-sm" />
        </div>
        <div>
          <label class="text-xs">Unit</label>
          ${getCustomSelectTemplate(unitSelectId, unitOptions, 'Select unit', '', 'bought-item-unit')}
        </div>
        <div>
          <label class="text-xs">Price</label>
          <input type="number" step="0.01" class="bought-item-price w-full px-2 py-1 border rounded text-sm" />
        </div>
        <div>
          <label class="text-xs">Total</label>
          <input type="number" step="0.01" class="bought-item-total w-full px-2 py-1 border rounded text-sm" readonly />
        </div>
        <div>
          <label class="text-xs">Supplier</label>
          <input type="text" class="bought-item-supplier w-full px-2 py-1 border rounded text-sm" />
        </div>
        <div class="md:col-span-2">
          <label class="text-xs">Notes</label>
          <input type="text" class="bought-item-notes w-full px-2 py-1 border rounded text-sm" />
        </div>
      </div>
    `;
    
    // Auto-calculate total
    const qtyInput = itemDiv.querySelector('.bought-item-qty');
    const priceInput = itemDiv.querySelector('.bought-item-price');
    const totalInput = itemDiv.querySelector('.bought-item-total');
    
    const updateTotal = () => {
      const qty = parseFloat(qtyInput.value) || 0;
      const price = parseFloat(priceInput.value) || 0;
      totalInput.value = (qty * price).toFixed(2);
    };
    
    qtyInput.addEventListener('input', updateTotal);
    priceInput.addEventListener('input', updateTotal);
    
    boughtItemsList.appendChild(itemDiv);

    const newUnitSelect = document.getElementById(unitSelectId);
    if (newUnitSelect) {
      initializeCustomSelect(newUnitSelect);
    }
  };
}

const toggleVehicleUpdatesBtn = document.getElementById('toggleVehicleUpdates');
if (toggleVehicleUpdatesBtn) {
  toggleVehicleUpdatesBtn.onclick = () => {
    const content = document.getElementById('vehicleUpdatesContent');
    if (!content) return;
    const isHidden = content.classList.contains('hidden');
    if (isHidden) {
      content.classList.remove('hidden');
      toggleVehicleUpdatesBtn.textContent = 'Hide Section';
    } else {
      content.classList.add('hidden');
      toggleVehicleUpdatesBtn.textContent = 'Show Section';
    }
  };
}

// Auto-calculate vehicle total cost
function updateVehicleTotalCost() {
  const vehicleFuelCostEl = document.getElementById('vehicleFuelCost');
  const vehicleLaborCostEl = document.getElementById('vehicleLaborCost');
  const vehicleTotalCostEl = document.getElementById('vehicleTotalCost');
  
  if (!vehicleFuelCostEl || !vehicleLaborCostEl || !vehicleTotalCostEl) return;
  
  const fuel = parseFloat(vehicleFuelCostEl.value) || 0;
  const labor = parseFloat(vehicleLaborCostEl.value) || 0;
  vehicleTotalCostEl.value = (fuel + labor).toFixed(2);
}

// Attach event listeners using event delegation (works even if elements are added dynamically)
document.addEventListener('input', function(e) {
  if (e.target.id === 'vehicleFuelCost' || e.target.id === 'vehicleLaborCost') {
    updateVehicleTotalCost();
  }
});

// Also attach on initial load if elements exist
const vehicleFuelCostEl = document.getElementById('vehicleFuelCost');
const vehicleLaborCostEl = document.getElementById('vehicleLaborCost');
if (vehicleFuelCostEl) vehicleFuelCostEl.addEventListener('input', updateVehicleTotalCost);
if (vehicleLaborCostEl) vehicleLaborCostEl.addEventListener('input', updateVehicleTotalCost);

// Attach button handlers immediately (will be re-attached after auth if needed)
attachButtonHandlers();

// Unified submit handler
async function handleSubmit(isDone) {
  console.log('📝 handleSubmit called, isDone:', isDone);
  console.log('📝 editingRecordId:', editingRecordId);
  
  const requiredFields = [fieldSelect, operationSelect, taskType];
  let hasEmpty = false;

  requiredFields.forEach(el => {
    if(!el || !el.value){
      console.warn('⚠️ Required field is empty:', el?.id || 'unknown');
      if (el) {
      el.classList.add('border-red-500');
      el.focus();
      const removeRed = () => {
        el.classList.remove('border-red-500');
        el.removeEventListener('input', removeRed);
        el.removeEventListener('change', removeRed);
      };
      el.addEventListener('input', removeRed);
      el.addEventListener('change', removeRed);
      }
      hasEmpty = true;
    }
  });

  if(hasEmpty) {
    console.warn('⚠️ Validation failed: required fields are empty');
    showNotification('error', 'Required Fields Missing', 'Please fill in Field, Operation, and Task Type before saving.');
    return;
  }
  
  console.log('✅ Basic validation passed');

  // For "Done Record", require Start Date and End Date
  const startDate = document.getElementById('startDate');
  const endDate = document.getElementById('endDate');
  if (isDone && startDate && !startDate.value) {
    startDate.classList.add('border-red-500');
    startDate.focus();
    showNotification('error', 'Start Date Required', 'Please provide a Start Date to mark this record as Done.');
    const removeRedStart = () => {
      startDate.classList.remove('border-red-500');
      startDate.removeEventListener('change', removeRedStart);
    };
    startDate.addEventListener('change', removeRedStart);
    return;
  }
  if (isDone && endDate && !endDate.value) {
    endDate.classList.add('border-red-500');
    endDate.focus();
    showNotification('error', 'End Date Required', 'Please provide an End Date to mark this record as Done.');
    const removeRed = () => {
      endDate.classList.remove('border-red-500');
      endDate.removeEventListener('change', removeRed);
    };
    endDate.addEventListener('change', removeRed);
    return;
  }

  // Map display name to taskFieldMap key (same logic as in taskType.onchange)
  const taskDisplayName = taskType.value;
  const taskKey = taskNameAliases[taskDisplayName] || taskDisplayName;
  const fields = taskFieldMap[taskKey] || [];
  const recordData = {};

for(const f of fields){
  const value = getFinalValue(f.id);
  
  // Include readonly fields in data (computed or not), but skip validation
  if(f.readonly) {
    recordData[f.id] = value;
    continue;
  }

  // All task type inputs are optional for both partial and done saves
  // Include ALL fields when updating (even empty) to overwrite old values; when creating, only include non-empty
  if (editingRecordId) {
    recordData[f.id] = value !== null ? value : '';
  } else {
    if (value !== '' && value !== null) {
      recordData[f.id] = value;
    }
  }
}

  // Collect Weeding Management special fields
  const dosageUnitSelect = document.getElementById('dosageUnit');
  if (dosageUnitSelect && dosageUnitSelect.value) {
    recordData.dosageUnit = dosageUnitSelect.value;
  }
  
  const chemicalQuantityInput = document.getElementById('chemicalQuantity');
  const chemicalPricePerPieceInput = document.getElementById('chemicalPricePerPiece');
  if (chemicalQuantityInput) {
    recordData.chemicalQuantity = parseFloat(chemicalQuantityInput.value) || 0;
  }
  if (chemicalPricePerPieceInput) {
    recordData.chemicalPricePerPiece = parseFloat(chemicalPricePerPieceInput.value) || 0;
  }
  
  // Collect enhanced Labor Cost supporting fields if enhanced version exists
  const laborCostEnhancedContainer = document.getElementById('laborCostEnhancedContainer');
  if (laborCostEnhancedContainer && !laborCostEnhancedContainer.classList.contains('hidden')) {
    const laborRatePerDay = document.getElementById('laborRatePerDay');
    const laborWorkers = document.getElementById('laborWorkers');
    const laborWorkingDays = document.getElementById('laborWorkingDays');
    // Use external Start Date and End Date for validation
    const startDate = document.getElementById('startDate');
    const endDate = document.getElementById('endDate');
    
    // Optional for both partial and done; if both dates are present and isDone, validate date order
    if (isDone && endDate && endDate.value && startDate && startDate.value && new Date(endDate.value) < new Date(startDate.value)) {
      endDate.classList.add('border-red-500');
      endDate.focus();
      const removeRed = () => {
        endDate.classList.remove('border-red-500');
        endDate.removeEventListener('change', removeRed);
      };
      endDate.addEventListener('change', removeRed);
      return;
    }
    
    // Calculate working days and labor totals if both dates are provided (no strict requirement)
    if (endDate && endDate.value && startDate && startDate.value) {
      const start = new Date(startDate.value);
      const end = new Date(endDate.value);
      const diffTime = end - start;
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 to include both start and end days
      const workingDays = Math.max(1, diffDays);
      
      if (laborWorkingDays) {
        laborWorkingDays.value = workingDays.toString();
      }
      
      // Recalculate labor cost if all fields are present
      if (laborRatePerDay && laborWorkers && laborWorkingDays) {
        const rate = parseFloat(laborRatePerDay.value) || 0;
        const workers = parseFloat(laborWorkers.value) || 0;
        const days = parseFloat(laborWorkingDays.value) || 0;
        const total = rate * workers * days;
        
        const laborCostInput = document.getElementById('laborCost');
        if (laborCostInput) {
          laborCostInput.value = total.toFixed(2);
        }
      }
    }
    
    // Collect values (for both partial and done saves)
    if (laborRatePerDay && laborRatePerDay.value) recordData.laborRatePerDay = parseFloat(laborRatePerDay.value) || 0;
    if (laborWorkers && laborWorkers.value) recordData.laborWorkers = parseFloat(laborWorkers.value) || 0;
    if (laborWorkingDays && laborWorkingDays.value) recordData.laborWorkingDays = parseFloat(laborWorkingDays.value) || 0;
  }

  // Extract variety name from dropdown value (e.g., "K 88-65 — 12–14 months" -> "K 88-65")
  // Also handle aliases like "PS 1 / VMC 84-947" -> "PS 1" or "PS 3 / VMC 84-524 / CADP Sc1" -> "PS 3"
  if (recordData.variety && recordData.variety !== 'Others') {
    if (recordData.variety.includes('—')) {
      // Extract the variety name (everything before the "—")
      recordData.variety = recordData.variety.split('—')[0].trim();
    }
    
    // Handle special cases with multiple names separated by "/"
    // Use the first name as the primary variety identifier
    if (recordData.variety.includes('/')) {
      recordData.variety = recordData.variety.split('/')[0].trim();
    }
  }
  
  // CRITICAL: Always collect notes/remarks field even if not in taskFieldMap
  // Notes field is added at the bottom of the form for all task types
  const notesInput = document.getElementById('notes');
  const remarksInput = document.getElementById('remarks');
  
  if (notesInput) {
    const notesValue = notesInput.value?.trim() || '';
    if (editingRecordId) {
      // When updating: always include notes (even if empty) to replace old value
      recordData.notes = notesValue;
      console.log('📝 Collected notes field:', notesValue);
    } else {
      // When creating: only include if not empty
      if (notesValue) {
        recordData.notes = notesValue;
      }
    }
  }
  
  if (remarksInput) {
    const remarksValue = remarksInput.value?.trim() || '';
    if (editingRecordId) {
      // When updating: always include remarks (even if empty) to replace old value
      recordData.remarks = remarksValue;
      console.log('📝 Collected remarks field:', remarksValue);
    } else {
      // When creating: only include if not empty
      if (remarksValue) {
        recordData.remarks = remarksValue;
      }
    }
  }

  // Also collect truckRented if it exists (from Mechanical selection)
  // For partial saves, this is optional; for done saves, validate if visible
  const truckRented = document.getElementById('truckRented');
  const truckRentedContainer = document.getElementById('truckRentedContainer');
  if(truckRented && truckRentedContainer && !truckRentedContainer.classList.contains('hidden')) {
    // Include truckRented value (for both partial and done saves)
    // When updating, include even if empty to replace old value
    if (editingRecordId) {
      // When updating: always include truckRented value (even if empty)
      recordData.truckRented = truckRented.value || '';
      
      // Collect rentCost if rentCost field exists (even if empty when updating)
      const rentCostInput = document.getElementById('rentCost');
      const rentCostContainer = document.getElementById('rentCostContainer');
      if(rentCostInput && rentCostContainer && !rentCostContainer.classList.contains('hidden')) {
        // When updating: include rentCost value (even if 0 or empty) to replace old value
        // When creating: only include if provided and > 0
        if (editingRecordId) {
          recordData.rentCost = parseFloat(rentCostInput.value) || 0;
        } else if (rentCostInput.value && parseFloat(rentCostInput.value) > 0) {
          recordData.rentCost = parseFloat(rentCostInput.value) || 0;
        }
      }
    } else {
      // When creating new record: only include if provided
      if (truckRented.value) {
    recordData.truckRented = truckRented.value;
    
    // Collect rentCost if truckRented is "Yes" and rentCost field exists
    if(truckRented.value === 'Yes') {
      const rentCostInput = document.getElementById('rentCost');
      const rentCostContainer = document.getElementById('rentCostContainer');
      if(rentCostInput && rentCostContainer && !rentCostContainer.classList.contains('hidden')) {
            // Include rentCost if provided (for both partial and done saves)
            if (rentCostInput.value && parseFloat(rentCostInput.value) > 0) {
        recordData.rentCost = parseFloat(rentCostInput.value) || 0;
            }
          }
        }
      }
    }
  }

  // Collect optional bought items
  const boughtItems = [];
  const boughtItemsListEl = document.getElementById('boughtItemsList');
  if (boughtItemsListEl) {
    const boughtItemElements = boughtItemsListEl.querySelectorAll('.border.rounded');
    boughtItemElements.forEach(itemEl => {
    const itemName = itemEl.querySelector('.bought-item-name')?.value?.trim();
    const quantity = parseFloat(itemEl.querySelector('.bought-item-qty')?.value) || 0;
    const unit = itemEl.querySelector('.bought-item-unit')?.value?.trim();
    const price = parseFloat(itemEl.querySelector('.bought-item-price')?.value) || 0;
    const total = parseFloat(itemEl.querySelector('.bought-item-total')?.value) || 0;
    const supplier = itemEl.querySelector('.bought-item-supplier')?.value?.trim();
    const notes = itemEl.querySelector('.bought-item-notes')?.value?.trim();
    
    if (itemName || quantity > 0 || price > 0) {
      boughtItems.push({
        itemName: itemName || '',
        quantity: quantity,
        unit: unit || '',
        price: price,
        total: total,
        supplier: supplier || '',
        notes: notes || ''
      });
    }
    });
  }

  // Collect optional vehicle updates
  let vehicleUpdates = null;
  const vehicleUpdatesContentEl = document.getElementById('vehicleUpdatesContent');
  if (vehicleUpdatesContentEl) {
    const vehicleType = vehicleUpdatesContentEl.querySelector('#vehicleType')?.value?.trim();
    const tripsBoxes = parseFloat(vehicleUpdatesContentEl.querySelector('#tripsBoxes')?.value) || 0;
    const vehicleFuelCost = parseFloat(vehicleUpdatesContentEl.querySelector('#vehicleFuelCost')?.value) || 0;
    const vehicleLaborCost = parseFloat(vehicleUpdatesContentEl.querySelector('#vehicleLaborCost')?.value) || 0;
    const vehicleTotalCost = parseFloat(vehicleUpdatesContentEl.querySelector('#vehicleTotalCost')?.value) || 0;
    const vehicleRoute = vehicleUpdatesContentEl.querySelector('#vehicleRoute')?.value?.trim();
    
    if (vehicleType || tripsBoxes > 0 || vehicleFuelCost > 0 || vehicleLaborCost > 0) {
      vehicleUpdates = {
        vehicleType: vehicleType || '',
        tripsBoxes: tripsBoxes,
        fuelCost: vehicleFuelCost,
        laborCost: vehicleLaborCost,
        totalCost: vehicleTotalCost,
        route: vehicleRoute || ''
      };
    }
  }

  // Extract date from record data for timeline sorting (prefer startDate, fallback to endDate)
  let recordDate = null;
  const dateFields = ['startDate', 'endDate', 'date', 'observationDate', 'assessmentDate', 'plantingDate', 'harvestDate', 'replantingDate'];
  for (const dateField of dateFields) {
    if (recordData[dateField]) {
      const dateValue = recordData[dateField];
      // Handle both Date objects and date strings
      if (dateValue instanceof Date) {
        recordDate = dateValue;
      } else if (typeof dateValue === 'string') {
        recordDate = new Date(dateValue);
      } else {
        recordDate = dateValue;
      }
      break;
    }
  }
  if (!recordDate) {
    recordDate = new Date(); // Use current date if no date field found
  }

  // Convert to Timestamp for Firestore
  const { Timestamp } = await import('https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js');
  const recordDateTimestamp = recordDate instanceof Date ? Timestamp.fromDate(recordDate) : Timestamp.fromDate(new Date(recordDate));

  // Auto-derive growth stage from operation + task type
  const growthStage = deriveGrowthStage(operationSelect.value, taskType.value);
  
  // Note: Ratooning is handled in operationSelect.onchange, so it won't reach here

  // Determine record status based on isDone flag
  const recordStatus = isDone ? 'Done' : 'Not Done Yet';

  pendingPayload = {
    userId: uid,
    fieldId: fieldSelect.value,
    growthStage: growthStage, // Auto-derived
    operation: operationSelect.value,
    taskType: taskType.value,
    data: recordData,
    boughtItems: boughtItems.length > 0 ? boughtItems : null,
    vehicleUpdates: vehicleUpdates,
    recordDate: recordDateTimestamp,
    recordStatus: recordStatus, // 'Done' or 'Not Done Yet'
    status: growthStage, // Legacy field for Firestore rules compatibility (uses growthStage)
    createdAt: serverTimestamp()
  };

  // Store isDone flag for use in confirmSave
  pendingPayload._isDone = isDone;
  
  console.log('✅ Payload prepared, showing confirmation modal');
  console.log('📦 Payload:', pendingPayload);
  console.log('📦 Record Data:', recordData);
  console.log('📦 Is updating:', !!editingRecordId);
  console.log('📦 Field count:', Object.keys(recordData).length);

  const confirmModal = document.getElementById('confirmModal');
  if (!confirmModal) {
    console.error('❌ Confirmation modal not found!');
    showNotification('error', 'Error', 'Confirmation modal not found. Please refresh the page.');
    return;
  }

  confirmModal.classList.remove('hidden');
  console.log('✅ Confirmation modal shown');
};


window.confirmSave = async () => {
  console.log('Saving...', pendingPayload);
  console.log('🔍 Editing Record ID:', editingRecordId);
  console.log('🔍 Is editing:', editingRecordId !== null);

  // Get record status from payload
  const isDone = pendingPayload._isDone === true;
  const recordStatus = pendingPayload.recordStatus || (isDone ? 'Done' : 'Not Done Yet');

  // Check if offline
  const isOnline = getOnlineStatus();
  // Always allow offline save if on Input Records page
  const canSaveOffline = window.location.pathname.includes('Input-Records.html');

  if (!isOnline && canSaveOffline) {
    // Save offline
    try {
      showLoading(true);
      closeConfirm();
      
      // Convert Firestore objects to serializable format for IndexedDB
      const serializeForIndexedDB = (obj) => {
        if (obj && typeof obj === 'object') {
          if (obj.toDate && typeof obj.toDate === 'function') {
            // Firestore Timestamp - convert to serializable format
            return {
              _type: 'Timestamp',
              seconds: obj.seconds,
              nanoseconds: obj.nanoseconds
            };
          }
          if (obj._methodName === 'serverTimestamp') {
            // serverTimestamp placeholder
            return { _methodName: 'serverTimestamp' };
          }
          if (Array.isArray(obj)) {
            return obj.map(serializeForIndexedDB);
          }
          const serialized = {};
          for (const key in obj) {
            serialized[key] = serializeForIndexedDB(obj[key]);
          }
          return serialized;
        }
        return obj;
      };
      
      const offlinePayload = serializeForIndexedDB(pendingPayload);
      
      await addPendingRecord(offlinePayload);
      
      showLoading(false);
      
      // Show floating notification about auto-sync (NO PAGE REFRESH)
      const statusText = recordStatus === 'Done' ? 'Done Record' : 'Partial Record';
      showNotification('success', `${statusText} Saved Offline`, 'This record will sync automatically when the internet is restored.', [
        {
          text: 'OK',
          type: 'primary',
          action: () => {
            // DO NOT refresh page - just dismiss notification
            // Allow user to continue inputting records offline
            hideNotification();
          }
        }
      ]);
      
      return;
    } catch (error) {
      console.error('Error saving offline:', error);
      showLoading(false);
      showNotification('error', 'Failed to Save Offline', 'An error occurred while saving offline. Please try again.');
      return;
    }
  }

  // Online save (original logic)
  // Show loading state
  showLoading(true);
  closeConfirm();

  try {
    // Prepare main record payload (without subcollections)
    const { boughtItems, vehicleUpdates, ...mainPayload } = pendingPayload;
    
    // If editing, update existing record; otherwise create new
    let recordId;
    if (editingRecordId) {
      console.log(`🔄 Updating existing record: ${editingRecordId}`);
      console.log(`📦 Update payload data fields:`, Object.keys(mainPayload.data || {}));
      console.log(`📦 Update payload data:`, mainPayload.data);
      
      const recordRef = doc(db, 'records', editingRecordId);
      
      // Don't overwrite createdAt when updating - preserve original creation time
      const { createdAt, ...updatePayload } = mainPayload;
      
      // CRITICAL: When updating, we need to ensure the 'data' object is completely replaced
      // Firestore's updateDoc merges nested objects, so we use setDoc with merge: true
      // This will merge top-level fields but completely replace the 'data' object
      const { setDoc } = await import('https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js');
      await setDoc(recordRef, updatePayload, { merge: true });
      
      // Note: setDoc with merge: true merges top-level fields but replaces nested objects
      // So the 'data' field will be completely replaced with our new data object
      recordId = editingRecordId;
      console.log(`✅ Updated existing record: ${recordId}`);
      console.log(`📦 Data object replaced with ${Object.keys(updatePayload.data || {}).length} fields`);
      console.log(`📦 Data fields:`, Object.keys(updatePayload.data || {}));
      
      // Delete old subcollections before adding new ones
      const oldBoughtItemsSnap = await getDocs(collection(db, 'records', recordId, 'bought_items'));
      for (const itemDoc of oldBoughtItemsSnap.docs) {
        await deleteDoc(itemDoc.ref);
      }
      const oldVehicleUpdatesSnap = await getDocs(collection(db, 'records', recordId, 'vehicle_updates'));
      for (const updateDoc of oldVehicleUpdatesSnap.docs) {
        await deleteDoc(updateDoc.ref);
      }
    } else {
      // Create new record
      console.log(`🆕 Creating new record`);
    const recordRef = await addDoc(collection(db, 'records'), mainPayload);
      recordId = recordRef.id;
      console.log(`✅ Created new record: ${recordId}`);
    }

    // Save bought items as subcollection if present
    if (boughtItems && boughtItems.length > 0) {
      const boughtItemsCollection = collection(db, 'records', recordId, 'bought_items');
      for (const item of boughtItems) {
        await addDoc(boughtItemsCollection, {
          ...item,
          createdAt: serverTimestamp()
        });
      }
    }

    // Save vehicle updates as subcollection if present
    if (vehicleUpdates) {
      const vehicleUpdatesCollection = collection(db, 'records', recordId, 'vehicle_updates');
      await addDoc(vehicleUpdatesCollection, {
        ...vehicleUpdates,
        createdAt: serverTimestamp()
      });
    }

    // CRITICAL: Only run automatic calculations for "Done" records
    // Partial records should not trigger growth tracking updates
    if (recordStatus === 'Done') {
      // Clear done tasks cache so the task disappears from Input Records immediately
      clearDoneTasksCache();
    // Handle predicted harvest logic for planting operations
      if (pendingPayload.growthStage === 'Germination' && 
        (pendingPayload.taskType === 'Planting Operation' || pendingPayload.taskType === 'Replanting / Gap Filling')) {
      try {
        // Get planting date - check startDate (new standard), then old field names for backward compatibility
        const plantingDate = pendingPayload.data.startDate || pendingPayload.data.plantingDate || pendingPayload.data.replantingDate || pendingPayload.data.date;
        const variety = pendingPayload.data.variety;
        
        if (plantingDate && variety) {
          // Import growth tracker function - use the same calculation as Planting Operation form
          const { calculateExpectedHarvestDateMonths } = await import('../../backend/Handler/growth-tracker.js');
          
          // Use calculateExpectedHarvestDateMonths (same as Planting Operation form) for consistency
          const plantingDateObj = plantingDate instanceof Date ? plantingDate : new Date(plantingDate);
          const harvestDateRange = calculateExpectedHarvestDateMonths(plantingDateObj, variety);
          
          if (!harvestDateRange) {
            console.error('Failed to calculate predicted harvest date range');
            return;
          }
          
          // Use earliest date for backward compatibility (database expects single date)
          // But all displays will use the formatted range from calculateExpectedHarvestDateMonths
          const predictedHarvestDate = harvestDateRange.earliest;
          
          console.log(`📅 Variety: ${variety}, Harvest Date Range: ${harvestDateRange.formatted}`);
          
          // Update field with predicted harvest date
          const { updateDoc, doc, Timestamp } = await import('https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js');
          const fieldRef = doc(db, 'fields', pendingPayload.fieldId);
          
          await updateDoc(fieldRef, {
            plantingDate: Timestamp.fromDate(plantingDateObj),
            sugarcane_variety: variety,
            expectedHarvestDate: Timestamp.fromDate(predictedHarvestDate),
            currentGrowthStage: 'Germination',
            status: 'active'
          });
          
          console.log('✅ Predicted harvest date updated:', harvestDateRange.formatted);
        }
      } catch (error) {
        console.error('Error updating predicted harvest:', error);
        // Don't fail the whole submission if harvest prediction fails
      }
    }

    // Auto-update field's currentGrowthStage from auto-derived growth stage
    if (pendingPayload.growthStage) {
      try {
        const { updateFieldGrowthData } = await import('../../backend/Handler/growth-tracker.js');
        await updateFieldGrowthData(uid, pendingPayload.fieldId, {
          currentGrowthStage: pendingPayload.growthStage
        });
        console.log(`✅ Updated field currentGrowthStage to: ${pendingPayload.growthStage}`);
      } catch (error) {
        console.error('Error updating field growth stage:', error);
        // Don't fail the whole submission if growth stage update fails
      }
      }
    } else {
      console.log(`ℹ️ Skipping automatic calculations for partial record (status: ${recordStatus})`);
    }

    // Hide loading and show success notification with action buttons
    showLoading(false);
    const fieldId = pendingPayload.fieldId;
    
    // Different messages for partial vs done records
    let notificationTitle, notificationMessage;
    const isEditing = editingRecordId !== null;
    if (recordStatus === 'Done') {
      notificationTitle = isEditing ? 'Record Updated and Completed!' : 'Record Completed Successfully!';
      notificationMessage = 'Your record has been marked as Done and will appear in the Growth Tracker timeline.';
      
      // Clear editing state only when record is marked as Done
      if (isEditing) {
        editingRecordId = null;
        // Remove editRecordId from URL
        const url = new URL(window.location.href);
        url.searchParams.delete('editRecordId');
        window.history.replaceState({}, '', url);
      }
      
      showNotification('success', notificationTitle, notificationMessage, [
      {
        text: 'View in Growth Tracker',
        type: 'primary',
        action: () => {
          window.location.href = `GrowthTracker.html?fieldId=${fieldId}`;
        }
      },
      {
        text: 'Stay Here',
        type: 'secondary',
        action: () => {
          location.reload();
        }
      }
    ]);
    } else {
      // Partial save - don't reload, allow continued editing
      notificationTitle = isEditing ? 'Record Updated (Not Done Yet)' : 'Record Saved (Not Done Yet)';
      notificationMessage = 'Your partial record has been saved. You can continue editing. Add an End Date and click "Done Record" to complete it and add it to the Growth Tracker.';
      
      // DON'T clear editingRecordId for partial saves - allow continued editing
      // DON'T reload the page - keep the form populated
      
      showNotification('success', notificationTitle, notificationMessage, [
        {
          text: 'OK',
          type: 'primary',
          action: () => {
            // Just dismiss notification, don't reload
            hideNotification();
          }
        }
      ]);
    }
  } catch(e) {
    console.error('Error saving record:', e);
    showLoading(false);
    showNotification('error', 'Failed to Save Record', e.message || 'An error occurred while saving. Please try again.');
  }
}


window.closeConfirm=()=>confirmModal.classList.add('hidden')

// Modern Notification System
let notificationTimeout = null;
let notificationCallbacks = [];

function showNotification(type, title, message, actions = null) {
  const banner = document.getElementById('notificationBanner');
  const content = document.getElementById('notificationContent');
  const icon = document.getElementById('notificationIcon');
  const iconI = document.getElementById('notificationIconI');
  const titleEl = document.getElementById('notificationTitle');
  const messageEl = document.getElementById('notificationMessage');
  const actionsEl = document.getElementById('notificationActions');
  
  // Clear any existing timeout
  if (notificationTimeout) {
    clearTimeout(notificationTimeout);
    notificationTimeout = null;
  }
  
  // Clear callbacks
  notificationCallbacks = [];
  
  // Remove all type classes
  content.classList.remove('success', 'error', 'loading', 'info');
  icon.classList.remove('success', 'error', 'loading', 'info');
  
  // Set type classes
  content.classList.add(type);
  icon.classList.add(type);
  
  // Set icon based on type
  if (type === 'success') {
    iconI.className = 'fas fa-check-circle';
  } else if (type === 'error') {
    iconI.className = 'fas fa-exclamation-circle';
  } else if (type === 'loading') {
    iconI.className = 'fas fa-spinner fa-spin';
  } else if (type === 'info') {
    iconI.className = 'fas fa-info-circle';
  }
  
  // Set content
  titleEl.textContent = title;
  messageEl.textContent = message;
  
  // Clear and populate actions
  actionsEl.innerHTML = '';
  if (actions && Array.isArray(actions)) {
    actions.forEach(action => {
      const btn = document.createElement('button');
      btn.className = `notification-btn notification-btn-${action.type || 'primary'}`;
      btn.textContent = action.text;
      if (action.icon) {
        const iconEl = document.createElement('i');
        iconEl.className = action.icon;
        btn.insertBefore(iconEl, btn.firstChild);
      }
      btn.onclick = () => {
        hideNotification();
        if (action.action) {
          setTimeout(() => action.action(), 400); // Wait for animation
        }
      };
      actionsEl.appendChild(btn);
    });
    notificationCallbacks = actions.map(a => a.action).filter(Boolean);
  } else if (actions && typeof actions === 'function') {
    // Backward compatibility: single callback
    notificationCallbacks = [actions];
  }
  
  // Show notification with animation
  setTimeout(() => {
    content.classList.add('show');
  }, 10);
  
  // Auto-hide after 8 seconds for success (longer to allow button clicks), 5 seconds for errors
  const autoHideDelay = type === 'error' ? 5000 : 8000;
  notificationTimeout = setTimeout(() => {
    hideNotification();
  }, autoHideDelay);
}

function hideNotification() {
  const content = document.getElementById('notificationContent');
  content.classList.remove('show');
  
  if (notificationTimeout) {
    clearTimeout(notificationTimeout);
    notificationTimeout = null;
  }
  
  // Clear callbacks (they're handled by button clicks)
  notificationCallbacks = [];
}

function showLoading(show) {
  const overlay = document.getElementById('loadingOverlay');
  if (show) {
    overlay.classList.add('show');
  } else {
    overlay.classList.remove('show');
  }
}

// Legacy toast function for backward compatibility
function toast(msg, err = false) {
  showNotification(err ? 'error' : 'success', err ? 'Error' : 'Success', msg);
}


window.handleOthers = (id) => {
  const select = document.getElementById(id);
  const otherInput = document.getElementById(id + '_other');

  if(!select || !otherInput) return;

  if(select.value === 'Others' || select.value === 'Other'){
    otherInput.classList.remove('hidden');
    otherInput.required = true;
  } else {
    otherInput.classList.add('hidden');
    otherInput.required = false;
    otherInput.value = '';
  }
};

// Also make handleOtherSelect available (for inline handlers)
window.handleOtherSelect = handleOtherSelect;

function getFinalValue(id){
  const el = document.getElementById(id);
  const other = document.getElementById(id + '_other');
  if(!el) return null;

  if(el.tagName === 'SELECT' && (el.value === 'Others' || el.value === 'Other')){
    return other?.value || '';
  }

  // ✅ Convert number inputs to number type
  if(el.type === 'number') return parseFloat(el.value) || 0;
  
  // ✅ Handle textarea
  if(el.tagName === 'TEXTAREA') return el.value;

  return el.value;
}

// Old toast element removed - using modern notification system instead
</script>

</body>
</html>
